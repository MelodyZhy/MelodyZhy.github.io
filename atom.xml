<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MelodyZhy的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://MelodyZhy.github.io/"/>
  <updated>2017-08-01T10:58:07.000Z</updated>
  <id>http://MelodyZhy.github.io/</id>
  
  <author>
    <name>庄 颖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Swift中的Protocol知道这些就够了</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Swift%E4%B8%AD%E7%9A%84Protocol%E7%9F%A5%E9%81%93%E8%BF%99%E4%BA%9B%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Swift中的Protocol知道这些就够了/</id>
    <published>2017-08-01T10:56:59.000Z</published>
    <updated>2017-08-01T10:58:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是Protocol？"><a href="#什么是Protocol？" class="headerlink" title="什么是Protocol？"></a>什么是Protocol？</h3><hr>
<h6 id="Protocol是Swift中的一种自定义类型，可以使用protocol定义某种约定，而不是某一种类型，一般用于表示某种类型的共性。"><a href="#Protocol是Swift中的一种自定义类型，可以使用protocol定义某种约定，而不是某一种类型，一般用于表示某种类型的共性。" class="headerlink" title="Protocol是Swift中的一种自定义类型，可以使用protocol定义某种约定，而不是某一种类型，一般用于表示某种类型的共性。"></a>Protocol是Swift中的一种自定义类型，可以使用protocol定义某种约定，而不是某一种类型，一般用于表示某种类型的共性。</h6><h3 id="Protocol-用法"><a href="#Protocol-用法" class="headerlink" title="Protocol 用法"></a>Protocol 用法</h3><hr>
<h6 id="定义一个protocol"><a href="#定义一个protocol" class="headerlink" title="定义一个protocol"></a>定义一个protocol</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PersonProtocol</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getSex</span><span class="params">()</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="某个class、struct或者enum要遵守这种约定的话，需要实现约定的方法"><a href="#某个class、struct或者enum要遵守这种约定的话，需要实现约定的方法" class="headerlink" title="某个class、struct或者enum要遵守这种约定的话，需要实现约定的方法"></a>某个class、struct或者enum要遵守这种约定的话，需要实现约定的方法</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">PersonProtocol</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span> &#123;</div><div class="line">         <span class="built_in">print</span>(<span class="string">"MelodyZhy"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getSex</span><span class="params">()</span></span> &#123;</div><div class="line">         <span class="built_in">print</span>(<span class="string">"boy"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="protocol中的约定方法，当方法中有参数时是不能有默认值的"><a href="#protocol中的约定方法，当方法中有参数时是不能有默认值的" class="headerlink" title="protocol中的约定方法，当方法中有参数时是不能有默认值的"></a>protocol中的约定方法，当方法中有参数时是不能有默认值的</h6><h6 id="protocol中也可以定义属性，但必须明确指定该属性支持的操作：只读（get）或者是可读写（get-set）"><a href="#protocol中也可以定义属性，但必须明确指定该属性支持的操作：只读（get）或者是可读写（get-set）" class="headerlink" title="protocol中也可以定义属性，但必须明确指定该属性支持的操作：只读（get）或者是可读写（get set）"></a>protocol中也可以定义属性，但必须明确指定该属性支持的操作：只读（get）或者是可读写（get set）</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PersonProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 我们也可以在protocol中定义属性</span></div><div class="line">    <span class="comment">// ⚠️必须明确指定该属性支持的操作：只读（get）或者是可读写（get set）</span></div><div class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getSex</span><span class="params">()</span></span></div><div class="line">    <span class="comment">// protocol中的约定方法，当方法中有参数时是不能有默认值的</span></div><div class="line">    <span class="comment">// ❌ Default argument not permitted in a protocol method</span></div><div class="line">    <span class="comment">// func getAge(age: Int = 18)</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getAge</span><span class="params">(age: Int)</span></span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="虽然height在protocol中是一个computed-property-但在遵守该约定的类型中可以简单的定义成一个stored-property"><a href="#虽然height在protocol中是一个computed-property-但在遵守该约定的类型中可以简单的定义成一个stored-property" class="headerlink" title="虽然height在protocol中是一个computed property,但在遵守该约定的类型中可以简单的定义成一个stored property"></a>虽然height在protocol中是一个computed property,但在遵守该约定的类型中可以简单的定义成一个stored property</h6><h6 id="当protocol中定义了一个只读属性，其实我们也可以在遵守该约定的类型中完成该属性的可读可写"><a href="#当protocol中定义了一个只读属性，其实我们也可以在遵守该约定的类型中完成该属性的可读可写" class="headerlink" title="当protocol中定义了一个只读属性，其实我们也可以在遵守该约定的类型中完成该属性的可读可写"></a>当protocol中定义了一个只读属性，其实我们也可以在遵守该约定的类型中完成该属性的可读可写</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PersonProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="keyword">var</span> weight: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getSex</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getAge</span><span class="params">(age: Int)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">PersonProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height = <span class="number">178</span></div><div class="line">    <span class="keyword">var</span> weight = <span class="number">120</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span> &#123;</div><div class="line">         <span class="built_in">print</span>(<span class="string">"MelodyZhy"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getSex</span><span class="params">()</span></span> &#123;</div><div class="line">         <span class="built_in">print</span>(<span class="string">"boy"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getAge</span><span class="params">(age: Int)</span></span> &#123;</div><div class="line">        <span class="built_in">print</span>(<span class="string">"age = <span class="subst">\(age)</span>"</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()</div><div class="line">person.height   <span class="comment">// 178</span></div><div class="line">person.height = <span class="number">180</span></div><div class="line">person.height  <span class="comment">// 180</span></div><div class="line"></div><div class="line">person.weight <span class="comment">// 120</span></div><div class="line"><span class="comment">// 可以更改（但在以前版本的Swift中是不能直接这样更改的</span></div><div class="line"><span class="comment">// 需要借助一个内部的stored property</span></div><div class="line"><span class="comment">// 然后把这个属性设计成一个computed property实现 get 和 set 方法）</span></div><div class="line">person.weight = <span class="number">130</span> <span class="comment">// 130</span></div><div class="line"><span class="comment">// 当我们把person从Person转换成PersonProtocol时 他就是只读的了</span></div><div class="line"><span class="comment">// ❌Cannot assign to property: 'weight' is a get-only property</span></div><div class="line">(person <span class="keyword">as</span> <span class="type">PersonProtocol</span>).weight = <span class="number">120</span></div></pre></td></tr></table></figure>
<h6 id="如何定义可选的protocol属性或者方法？"><a href="#如何定义可选的protocol属性或者方法？" class="headerlink" title="如何定义可选的protocol属性或者方法？"></a>如何定义可选的protocol属性或者方法？</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">PersonProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">optional</span> <span class="keyword">var</span> height: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="keyword">optional</span> <span class="keyword">var</span> weight: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">getSex</span><span class="params">()</span></span></div><div class="line">    <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">getAge</span><span class="params">(age: Int)</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>: <span class="title">PersonProtocol</span> </span>&#123;</div><div class="line">    <span class="comment">// 如果想提供可选的约定方法或者属性那么只能定义@objc的protocol</span></div><div class="line">    <span class="comment">// 并且这种约定只能class能遵守</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="protocol可以继承，当然struct、class、enum都可以同时遵守多个约定"><a href="#protocol可以继承，当然struct、class、enum都可以同时遵守多个约定" class="headerlink" title="protocol可以继承，当然struct、class、enum都可以同时遵守多个约定"></a>protocol可以继承，当然struct、class、enum都可以同时遵守多个约定</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 例如:</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PersonProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</div><div class="line">    <span class="keyword">var</span> weight: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getName</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getSex</span><span class="params">()</span></span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">getAge</span><span class="params">(age: Int)</span></span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Engineer</span>: <span class="title">PersonProtocol</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> good: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">Engineer</span>, <span class="title">Animal</span> </span>&#123;</div><div class="line">    <span class="comment">// 省略了该实现约定的方法和属性</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="这些protocol需要我们掌握"><a href="#这些protocol需要我们掌握" class="headerlink" title="这些protocol需要我们掌握"></a>这些protocol需要我们掌握</h3><hr>
<h6 id="CustomStringConvertible"><a href="#CustomStringConvertible" class="headerlink" title="CustomStringConvertible"></a>CustomStringConvertible</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> x: <span class="type">Int</span></div><div class="line">    <span class="keyword">var</span> y: <span class="type">Int</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> p = <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)</div><div class="line"><span class="built_in">print</span>(p) <span class="comment">// Point(x: 10, y: 10)</span></div><div class="line"><span class="comment">// 如果我们想让打印界面变成 x ＝ 10, y = 10 </span></div><div class="line"><span class="comment">// 那么我们就要遵守 CustomStringConvertible 这个 protocol</span></div><div class="line"><span class="comment">// 来看下实现</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span>: <span class="title">CustomStringConvertible</span> </span>&#123;</div><div class="line">    <span class="comment">// 这个 protocol 只有一个约定定义一个名为description的属性</span></div><div class="line">    <span class="keyword">var</span> description: <span class="type">String</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"x = <span class="subst">\(<span class="keyword">self</span>.x)</span>, y = <span class="subst">\(<span class="keyword">self</span>.y)</span>"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(p) <span class="comment">// x = 10, y = 10\n</span></div></pre></td></tr></table></figure>
<h6 id="BooleanType"><a href="#BooleanType" class="headerlink" title="BooleanType"></a>BooleanType</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如何更优雅的判断该点是不是原点(0, 0)</span></div><div class="line"><span class="comment">// 来一起看下</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span>: <span class="title">BooleanType</span> </span>&#123;</div><div class="line">    <span class="comment">// 遵守BooleanType这个protocol</span></div><div class="line">    <span class="comment">// 这个protocol也只需要一个实现一个名为boolValue的属性</span></div><div class="line">    <span class="keyword">var</span> boolValue: <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.x == <span class="number">0</span> &amp;&amp; <span class="keyword">self</span>.y == <span class="number">0</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> p = <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)</div><div class="line"><span class="comment">// 这样我们就能这样进行判断了</span></div><div class="line"><span class="keyword">if</span> p &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"是原点(0, 0)"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"不是原点"</span>)</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这个protocol可以用到项目的好多地方，开发自己的脑洞去吧！</span></div></pre></td></tr></table></figure>
<h6 id="Equatable"><a href="#Equatable" class="headerlink" title="Equatable"></a>Equatable</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span>: <span class="title">Equatable</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> == <span class="params">(lP: Point, rP: Point)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">let</span> equalX = lP.x == rP.x</div><div class="line">    <span class="keyword">let</span> equalY = lP.y == rP.y</div><div class="line">    <span class="keyword">return</span> equalX &amp;&amp; equalY</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> lP = <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)</div><div class="line"><span class="keyword">let</span> rP = <span class="type">Point</span>(x: <span class="number">10</span>, y: <span class="number">10</span>)</div><div class="line"><span class="comment">// 不要以为是我们重载了 == 函数 就能自动推导出 !=</span></div><div class="line"><span class="comment">// 其实这都是 Equatable 这个 protocol 的功劳</span></div><div class="line"><span class="comment">// 当然我们如果要遵守 Equatable 这个 protocol 就必须实现 == 函 数 或者  != 函数</span></div><div class="line"><span class="comment">// 如果我们只是重载了 == 函数 是不能用 !=</span></div><div class="line"><span class="keyword">if</span> lP != rP &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"unequal"</span>)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">print</span>(<span class="string">"equal"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 想遵守 Comparable 这个 protocol 必须遵守 Equatable</span></div><div class="line"><span class="comment">// 同时用必须实现 &lt; 函数 或者 &gt; 函数</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Point</span>: <span class="title">Comparable</span> </span>&#123;&#125;</div><div class="line"><span class="comment">// 同样 &gt; 函数会自动推导出来</span></div><div class="line"><span class="function"><span class="keyword">func</span> &lt; (lP: Point, rP: Point) -&gt; <span class="title">Bool</span> </span>&#123;</div><div class="line">    <span class="comment">// 随意定义的规则 不必在意</span></div><div class="line">    <span class="keyword">let</span> x = lP.x - rP.x</div><div class="line">    <span class="keyword">let</span> y = lP.y - rP.y</div><div class="line">    <span class="keyword">return</span> x &lt; y</div><div class="line">&#125;</div><div class="line"><span class="comment">// 实现了 Comparable 我们就可以把 Point 放到 Array 中，同时支持使用各种排序方法</span></div></pre></td></tr></table></figure>
<h2 id="protocol-extension"><a href="#protocol-extension" class="headerlink" title="protocol extension"></a>protocol extension</h2><hr>
<h6 id="protocol-extension-最关键的一点就是能在-protocol-extension-方法中获取-protocol-的属性，因为Swift编译器知道任何一个遵守-protocol-的自定义类型，一定会定义这个-protocol-约定的各种属性，既然这样我们就可以在-protocol-extension-中添加默认的实现了。这也是为什么会有-protocol-oriented-programming-这个概念，但这时候肯定会有人说我通过面对对象的编程方式也可以实现，但为什么要用遵守-protocol-的方法呢，这个要等到了解-extension-中的-type-constraints-后解释…"><a href="#protocol-extension-最关键的一点就是能在-protocol-extension-方法中获取-protocol-的属性，因为Swift编译器知道任何一个遵守-protocol-的自定义类型，一定会定义这个-protocol-约定的各种属性，既然这样我们就可以在-protocol-extension-中添加默认的实现了。这也是为什么会有-protocol-oriented-programming-这个概念，但这时候肯定会有人说我通过面对对象的编程方式也可以实现，但为什么要用遵守-protocol-的方法呢，这个要等到了解-extension-中的-type-constraints-后解释…" class="headerlink" title="protocol extension 最关键的一点就是能在 protocol extension 方法中获取 protocol 的属性，因为Swift编译器知道任何一个遵守 protocol 的自定义类型，一定会定义这个 protocol 约定的各种属性，既然这样我们就可以在 protocol extension 中添加默认的实现了。这也是为什么会有 protocol oriented programming 这个概念，但这时候肯定会有人说我通过面对对象的编程方式也可以实现，但为什么要用遵守 protocol 的方法呢，这个要等到了解 extension 中的 type constraints 后解释…"></a>protocol extension 最关键的一点就是能在 protocol extension 方法中获取 protocol 的属性，因为Swift编译器知道任何一个遵守 protocol 的自定义类型，一定会定义这个 protocol 约定的各种属性，既然这样我们就可以在 protocol extension 中添加默认的实现了。这也是为什么会有 protocol oriented programming 这个概念，但这时候肯定会有人说我通过面对对象的编程方式也可以实现，但为什么要用遵守 protocol 的方法呢，这个要等到了解 extension 中的 type constraints 后解释…</h6><h6 id="先看一个通过-protocol-extension-添加默认实现的代码例子"><a href="#先看一个通过-protocol-extension-添加默认实现的代码例子" class="headerlink" title="先看一个通过 protocol extension 添加默认实现的代码例子"></a>先看一个通过 protocol extension 添加默认实现的代码例子</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义一个人属性的 protocol</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">PersonProperty</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height: <span class="type">Int</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// cm</span></div><div class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125; <span class="comment">// kg</span></div><div class="line">    <span class="comment">// 判断体重是否合格的函数</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isStandard</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PersonProperty</span> </span>&#123;</div><div class="line">    <span class="comment">// 给 protocol 添加默认的实现</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isStandard</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.weight == <span class="type">Double</span>((height - <span class="number">100</span>)) * <span class="number">0.9</span></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 给 protocol 添加默认属性</span></div><div class="line">    <span class="keyword">var</span> isPerfectHeight: <span class="type">Bool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.height == <span class="number">178</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">PersonProperty</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> height: <span class="type">Int</span></div><div class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span></div><div class="line">    <span class="comment">// 如果自定义类型里面创建了遵守的 protocol 中的方法</span></div><div class="line">    <span class="comment">// 那么他将覆盖 protocol 中的方法</span></div><div class="line"><span class="comment">//    func isStandard() -&gt; Bool &#123;</span></div><div class="line"><span class="comment">//        return true</span></div><div class="line"><span class="comment">//    &#125;</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 创建遵守 PersonProperty 的自定义类型</span></div><div class="line"><span class="keyword">let</span> p = <span class="type">Person</span>(height: <span class="number">178</span>, weight: <span class="number">61.5</span>)</div><div class="line"><span class="comment">// 那么 p 这个自定义类型 天生就有判断这个人身高体重是否合格的方法</span></div><div class="line">p.isStandard() <span class="comment">// false</span></div><div class="line"><span class="comment">// 同样天生具有判断是否是 Perfect Height 的属性</span></div><div class="line">p.isPerfectHeight <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="protocol-extension-中的-type-constraints"><a href="#protocol-extension-中的-type-constraints" class="headerlink" title="protocol extension 中的 type constraints"></a>protocol extension 中的 type constraints</h2><hr>
<h6 id="这相当于给-protocol-extension-中的默认实现添加限定条件-写法如下"><a href="#这相当于给-protocol-extension-中的默认实现添加限定条件-写法如下" class="headerlink" title="这相当于给 protocol extension 中的默认实现添加限定条件,写法如下"></a>这相当于给 protocol extension 中的默认实现添加限定条件,写法如下</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 运动因素的 protocol</span></div><div class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">SportsFactors</span> </span>&#123;</div><div class="line">    <span class="comment">// 运动量</span></div><div class="line">    <span class="keyword">var</span> sportQuantity: <span class="type">Double</span> &#123; <span class="keyword">get</span> &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 下面这种写法就用到了 extension 中的 type constraints</span></div><div class="line"><span class="comment">// 意思是 只有同时遵守了 SportsFactors 和 PersonProperty 时</span></div><div class="line"><span class="comment">// 才使 PersonProperty 获得扩展 并提供带有 sportQuantity 属性的 isStandard 方法</span></div><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PersonProperty</span> <span class="title">where</span> <span class="title">Self</span>: <span class="title">SportsFactors</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">isStandard</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">        <span class="comment">// 随意写的算法 不要在意</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.weight == <span class="type">Double</span>((height - <span class="number">100</span>)) * <span class="number">0.9</span> - <span class="keyword">self</span>.sportQuantity</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="protocol-oriented-programming-的优点"><a href="#protocol-oriented-programming-的优点" class="headerlink" title="protocol oriented programming 的优点"></a>protocol oriented programming 的优点</h2><hr>
<h6 id="1、首先继承是-class-专有的，所以它不能用来扩展其他类型，但-protocol-是没有这种局限性的"><a href="#1、首先继承是-class-专有的，所以它不能用来扩展其他类型，但-protocol-是没有这种局限性的" class="headerlink" title="1、首先继承是 class 专有的，所以它不能用来扩展其他类型，但 protocol 是没有这种局限性的"></a>1、首先继承是 class 专有的，所以它不能用来扩展其他类型，但 protocol 是没有这种局限性的</h6><h6 id="2、试想一下，上面的代码你用面对对象的编程方式的话可能你就需要多一个运动量的属性，同时也要修改-isStandard-函数，一切看起来特别自然，随着后续需求的更改可能会有更多因素影响是否是合格的体重，那么这时候你就会在不知不觉中将你代码的耦合度成倍提高，其实对于这个类来说，他完全不需要知道是否是合格体重的计算细节，所以我们完全可以把这些类型无关的细节从类型定义上移出去，用一个-protocol-封装好这些细节，然后让其成为这个类型的一种修饰，这就是POP的核心思想。"><a href="#2、试想一下，上面的代码你用面对对象的编程方式的话可能你就需要多一个运动量的属性，同时也要修改-isStandard-函数，一切看起来特别自然，随着后续需求的更改可能会有更多因素影响是否是合格的体重，那么这时候你就会在不知不觉中将你代码的耦合度成倍提高，其实对于这个类来说，他完全不需要知道是否是合格体重的计算细节，所以我们完全可以把这些类型无关的细节从类型定义上移出去，用一个-protocol-封装好这些细节，然后让其成为这个类型的一种修饰，这就是POP的核心思想。" class="headerlink" title="2、试想一下，上面的代码你用面对对象的编程方式的话可能你就需要多一个运动量的属性，同时也要修改 isStandard 函数，一切看起来特别自然，随着后续需求的更改可能会有更多因素影响是否是合格的体重，那么这时候你就会在不知不觉中将你代码的耦合度成倍提高，其实对于这个类来说，他完全不需要知道是否是合格体重的计算细节，所以我们完全可以把这些类型无关的细节从类型定义上移出去，用一个 protocol 封装好这些细节，然后让其成为这个类型的一种修饰，这就是POP的核心思想。"></a>2、试想一下，上面的代码你用面对对象的编程方式的话可能你就需要多一个运动量的属性，同时也要修改 isStandard 函数，一切看起来特别自然，随着后续需求的更改可能会有更多因素影响是否是合格的体重，那么这时候你就会在不知不觉中将你代码的耦合度成倍提高，其实对于这个类来说，他完全不需要知道是否是合格体重的计算细节，所以我们完全可以把这些类型无关的细节从类型定义上移出去，用一个 protocol 封装好这些细节，然后让其成为这个类型的一种修饰，这就是POP的核心思想。</h6><h6 id="3、当有多种因素制约是否是合格体重时，我们可以用多个-protocol-来对该类型进行修饰，每一种修饰的相关细节，我们都在对应的-protocol-extension-中单独的封装起来，这样就大大降低了代码的耦合度，同时代码的可维护性也得到了相应的提高。swift标准库中大部分都是用这种思想构建的。"><a href="#3、当有多种因素制约是否是合格体重时，我们可以用多个-protocol-来对该类型进行修饰，每一种修饰的相关细节，我们都在对应的-protocol-extension-中单独的封装起来，这样就大大降低了代码的耦合度，同时代码的可维护性也得到了相应的提高。swift标准库中大部分都是用这种思想构建的。" class="headerlink" title="3、当有多种因素制约是否是合格体重时，我们可以用多个 protocol 来对该类型进行修饰，每一种修饰的相关细节，我们都在对应的 protocol extension 中单独的封装起来，这样就大大降低了代码的耦合度，同时代码的可维护性也得到了相应的提高。swift标准库中大部分都是用这种思想构建的。"></a>3、当有多种因素制约是否是合格体重时，我们可以用多个 protocol 来对该类型进行修饰，每一种修饰的相关细节，我们都在对应的 protocol extension 中单独的封装起来，这样就大大降低了代码的耦合度，同时代码的可维护性也得到了相应的提高。swift标准库中大部分都是用这种思想构建的。</h6><h6 id="最终我们的写法可能是这样的"><a href="#最终我们的写法可能是这样的" class="headerlink" title="最终我们的写法可能是这样的"></a>最终我们的写法可能是这样的</h6><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>: <span class="title">PersonProperty</span>, <span class="title">SportsFactors</span> ... </span>&#123;</div><div class="line">    <span class="keyword">var</span> height: <span class="type">Int</span></div><div class="line">    <span class="keyword">var</span> weight: <span class="type">Double</span></div><div class="line">    <span class="keyword">var</span> sportQuantity: <span class="type">Double</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是Protocol？&quot;&gt;&lt;a href=&quot;#什么是Protocol？&quot; class=&quot;headerlink&quot; title=&quot;什么是Protocol？&quot;&gt;&lt;/a&gt;什么是Protocol？&lt;/h3&gt;&lt;hr&gt;
&lt;h6 id=&quot;Protocol是Swift中的一种自定
    
    </summary>
    
    
      <category term="Swift" scheme="http://MelodyZhy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的泛型</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Swift%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Swift中的泛型/</id>
    <published>2017-08-01T10:55:41.000Z</published>
    <updated>2017-08-01T10:56:38.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>时隔1个月，2个月，3个月。。。我终于回来了。。公司项目太忙了以至于简书一直没有更新。而且公司项目还是OC的。。最近忙的也差不多了，还得继续学咱们的Swift啊，那么今天呢，就写一篇我对Swift中泛型的理解吧。</p>
</blockquote>
<h3 id="泛型（generic）"><a href="#泛型（generic）" class="headerlink" title="泛型（generic）"></a>泛型（generic）</h3><p>泛型是Swift的强大特征之一，它可以让我们的代码更加灵活，让我们的函数可重用性更高，可以让我们的代码更利于维护，逻辑更加清晰。</p>
<hr>
<h3 id="泛型的使用场景"><a href="#泛型的使用场景" class="headerlink" title="泛型的使用场景"></a>泛型的使用场景</h3><p>现在我们有一个这样的需求交换两个整数的值，那么我们的函数可能是这样写的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> b: Int)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temp = a</div><div class="line">    a = b</div><div class="line">    b = temp</div><div class="line">&#125;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">10</span></div><div class="line">    <span class="keyword">var</span> b = <span class="number">20</span></div><div class="line">    <span class="comment">// 函数调用</span></div><div class="line">    swapInt(&amp;a, b: &amp;b)</div></pre></td></tr></table></figure>
<p>这时候我们感觉万事大吉了，下班回家！产品一句话需求改了现在要交换两个String的值，沃嚓。。难到还得写个函数，这时候Swift中泛型的作用就有展现的地方了，只需稍作改动我们的函数就会变得非常强大。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapGeneric</span> &lt;T&gt;<span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> b: T)</span></span> &#123;</div><div class="line">    <span class="keyword">let</span> temp = a</div><div class="line">    a = b</div><div class="line">    b = temp</div><div class="line">&#125;</div><div class="line">    <span class="keyword">var</span> str = <span class="string">"Hello, playground"</span></div><div class="line">    <span class="keyword">var</span> str1 = <span class="string">"Hello, World"</span></div><div class="line">    <span class="comment">// 函数调用</span></div><div class="line">    swapGeneric(&amp;str, b: &amp;str1)</div></pre></td></tr></table></figure>
<p>那么我们来对比一下这两个函数</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">inout</span> a: Int, <span class="keyword">inout</span> b: Int)</span></span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapGeneric</span>&lt;T&gt;<span class="params">(<span class="keyword">inout</span> a: T, <span class="keyword">inout</span> b: T)</span></span></div></pre></td></tr></table></figure>
<p>我们可以容易的发现泛型函数无非就是使用了节点类型命名，通常我们用字母T来代替实际类型名(如Int，String，Float等)，当有多种类型的时候可以用U，E或其他字符表示，这个没有强制要求，都是写习惯了自然就用那几个字母了。节点类型名并不是表示T必须是任何类型，而是表示规定a和b必须是同一个类型的T，只有函数在每一次调用的时候传入的实际类型才能决定T所代表的类型。</p>
<hr>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><p>我们有一个判断两个参数是否相等的泛型函数，如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ❌</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEquals</span>&lt;T&gt;<span class="params">(a: T, b: T)</span></span> -&gt; <span class="type">Bool</span> &#123;</div><div class="line">    <span class="keyword">return</span> (a == b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>是不是你也觉得这样写是对的？这样写其实很明显是错误的，仔细想一下a和b有可比性嘛，很显然是没有的，所以我们需要这个泛型T遵守Comparable协议，也就是我们要给这个泛型T添加约束，只有符合这个约束的类型才能使用这个函数，改进的函数如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// ✅</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">isEquals</span>&lt;T: Comparable&gt;<span class="params">(a: T, b: T)</span></span> -&gt; <span class="type">Bool</span> &#123;　</div><div class="line">    <span class="keyword">return</span> (a == b)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<blockquote>
<p>如果你使用Swift编写代码，却说自己没有用到过泛型，那只能说明😄。。许多Swift标准库是通过泛型代码构建出来的，最常见的例子：Swift的Array和Dictionary类型都是泛型集，你可以创建Int类型的数组，也可以创建String类型的，同样也可以创建存储任何指定类型的字典，而且这些类型可以是没有限制的。</p>
</blockquote>
<h3 id="更深入的理解泛型"><a href="#更深入的理解泛型" class="headerlink" title="更深入的理解泛型"></a>更深入的理解泛型</h3><p>上一篇简书我们介绍了Swift数组中Map,FlatMap,Filter,Reduce的使用，那么今天就来说一下Map以及Reduce的内部实现，从而更深入的理解Swift中的泛型。</p>
<h4 id="MyMap"><a href="#MyMap" class="headerlink" title="MyMap"></a>MyMap</h4><p>首先我们先看看使用Swift中原有map的实现，代码如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>]</div><div class="line"><span class="comment">// 将字符串转换成字符串的长度</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fruit</span><span class="params">(fruit: String)</span></span> -&gt; <span class="type">Int</span>? &#123;</div><div class="line">    <span class="keyword">let</span> length = fruit.characters.<span class="built_in">count</span></div><div class="line">    <span class="keyword">guard</span> length &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> length</div><div class="line">&#125;</div><div class="line"><span class="comment">// map接受一个定义规则的函数</span></div><div class="line"><span class="keyword">let</span> counts = fruits.<span class="built_in">map</span>(fruit)</div><div class="line"><span class="comment">// [Optional(5), Optional(6), Optional(6)]</span></div><div class="line"><span class="built_in">print</span>(counts)</div></pre></td></tr></table></figure>
<p>接下来我们实现一下自己的map，代码如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="comment">// 定义 BeforeType 为之前的类型 BecomeType 为最终转化成的类型</span></div><div class="line">    <span class="comment">// 这里我们需要接受一个transform闭包，来定义我们转化的规则</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myMap</span>&lt;BeforeType, BecomeType&gt;<span class="params">(transform:</span></span></div><div class="line"><span class="function"><span class="params">        <span class="params">(BeforeType)</span></span></span> -&gt; (<span class="type">BecomeType</span>)) -&gt; [<span class="type">BecomeType</span>] &#123;</div><div class="line">        <span class="comment">// 定义一个转化后类型的空数组</span></div><div class="line">        <span class="keyword">var</span> output: [<span class="type">BecomeType</span>] = []</div><div class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">self</span> &#123;</div><div class="line">            <span class="comment">// 通过闭包转化类型</span></div><div class="line">            <span class="keyword">let</span> transformed =</div><div class="line">                transform(item <span class="keyword">as</span>! <span class="type">BeforeType</span>)</div><div class="line">            <span class="comment">// 添加到之前的创建的空数组</span></div><div class="line">            output.append(transformed)</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> output</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>]</div><div class="line"><span class="comment">// 将字符串转换成字符串的长度</span></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">fruit</span><span class="params">(fruit: String)</span></span> -&gt; <span class="type">Int</span>? &#123;</div><div class="line">    <span class="keyword">let</span> length = fruit.characters.<span class="built_in">count</span></div><div class="line">    <span class="keyword">guard</span> length &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> length</div><div class="line">&#125;</div><div class="line"><span class="comment">// map接受一个定义规则的函数</span></div><div class="line"><span class="keyword">let</span> counts = fruits.myMap(fruit)</div><div class="line"><span class="comment">// 我们可以看到返回的结果是一样的</span></div><div class="line"><span class="comment">// [Optional(5), Optional(6), Optional(6)]</span></div><div class="line"><span class="built_in">print</span>(counts)</div><div class="line"><span class="comment">// 由此可以看出map内部就是这样实现的</span></div></pre></td></tr></table></figure>
<h4 id="MyReduce"><a href="#MyReduce" class="headerlink" title="MyReduce"></a>MyReduce</h4><p>首先我们先看看使用Swift中原有reduce的实现，代码如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="comment">// reduce有两个参数，第一个是用来表示第一次“合并”之前的初始值。因为我们要求和，所以它是0。</span></div><div class="line"><span class="comment">// 第二个参数combine是一个闭包，用来表示“合并”的规则。</span></div><div class="line"><span class="comment">// 它的第一个参数是“每一次合并前”的初始值，第二个参数是要“合并”进来的对象。</span></div><div class="line"><span class="comment">// 在我们的例子里，$0是0，$1表示数组中的每一个对象。</span></div><div class="line"><span class="keyword">let</span> sum = numArray.<span class="built_in">reduce</span>(<span class="number">0</span>, combine: &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;)</div><div class="line"><span class="comment">// 21</span></div><div class="line"><span class="built_in">print</span>(sum)</div></pre></td></tr></table></figure>
<p>接下来我们实现一下自己的reduce</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="comment">// 由于最终“合并”出来的结果有可能和参与合并的值类型不同</span></div><div class="line">    <span class="comment">//（例如：把一个整数数组拼接成一个字符串）</span></div><div class="line">    <span class="comment">// 所以myReduce需要两个泛型类型</span></div><div class="line">    <span class="comment">// 一个表示“合并”后的类型BecomeType</span></div><div class="line">    <span class="comment">// 一个表示参与“合并”的类型BeforeType</span></div><div class="line">    <span class="comment">// myReduce接受两个参数，initial用来表示整个合并前的初始值，它的类型是BecomeType</span></div><div class="line">    <span class="comment">// combine是一个闭包，用来表示合并的规则。</span></div><div class="line">    <span class="comment">// 每一次调用，都是把当前要合并的值合并到上一次的合并结果里，然后把新的合并结果返回</span></div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">myReduce</span>&lt;BecomeType, BeforeType&gt;<span class="params">(initial: BecomeType,</span></span></div><div class="line"><span class="function"><span class="params">                  combine: <span class="params">(BecomeType, BeforeType)</span></span></span> -&gt; <span class="type">BecomeType</span>) -&gt; <span class="type">BecomeType</span> &#123;</div><div class="line">        <span class="keyword">var</span> seed = initial</div><div class="line"></div><div class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> <span class="keyword">self</span> &#123;</div><div class="line">            seed = combine(seed, item <span class="keyword">as</span>! <span class="type">BeforeType</span>)</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 最后，当所有的合并都完成之后，myReduce返回最终的值</span></div><div class="line">        <span class="keyword">return</span> seed</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> numArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</div><div class="line"><span class="keyword">let</span> sum = numArray.myReduce(<span class="number">0</span>, combine: &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;)</div><div class="line"><span class="comment">// 21</span></div><div class="line"><span class="built_in">print</span>(sum)</div></pre></td></tr></table></figure>
<hr>
<p>好了，Swift中泛型的介绍就到这了，接下来我会写一些有关POP和Reactive Programming方面的介绍，欢迎大家持续关注我，这次我不会脱更那么久了哦～</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;时隔1个月，2个月，3个月。。。我终于回来了。。公司项目太忙了以至于简书一直没有更新。而且公司项目还是OC的。。最近忙的也差不多了，还得继续学咱们的Swift啊，那么今天呢，就写一篇我对Swift中泛型的理解吧。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://MelodyZhy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift数组中Map,FlatMap,Filter,Reduce的使用</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Swift%E6%95%B0%E7%BB%84%E4%B8%ADMap-FlatMap-Filter-Reduce%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Swift数组中Map-FlatMap-Filter-Reduce的使用/</id>
    <published>2017-08-01T10:54:02.000Z</published>
    <updated>2017-08-01T10:55:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><blockquote>
<p>map函数能够被数组调用，它接受一个闭包作为参数，作用于数组中的每个元素。闭包返回一个变换后的元素，接着将所有这些变换后的元素组成一个新的数组</p>
</blockquote>
<h4 id="1-比如我们有一个这样的需求遍历一个数组中所有的元素，将每个元素自身与自身相加，最后返回一个保存相加后元素的数组-原谅我这表达能力-下面用代码阐述"><a href="#1-比如我们有一个这样的需求遍历一个数组中所有的元素，将每个元素自身与自身相加，最后返回一个保存相加后元素的数组-原谅我这表达能力-下面用代码阐述" class="headerlink" title="1. 比如我们有一个这样的需求遍历一个数组中所有的元素，将每个元素自身与自身相加，最后返回一个保存相加后元素的数组(-_-原谅我这表达能力,下面用代码阐述)"></a>1. 比如我们有一个这样的需求遍历一个数组中所有的元素，将每个元素自身与自身相加，最后返回一个保存相加后元素的数组(-_-原谅我这表达能力,下面用代码阐述)</h4><p>如果我们不使用map函数，那么代码如下</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">var</span> sumNumbers = [<span class="type">Int</span>]()</div><div class="line"><span class="keyword">for</span> <span class="keyword">var</span> number <span class="keyword">in</span> numbers &#123;</div><div class="line">    number += number</div><div class="line">    sumNumbers.append(number)</div><div class="line">&#125;</div><div class="line"><span class="comment">// [2,4,6]</span></div><div class="line"><span class="built_in">print</span>(sumNumbers)</div></pre></td></tr></table></figure>
<p>可以看到上面的代码正是我们经常用到的代码，但通过数组的map函数可以帮我们简化上面的代码</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 可以看到我们甚至可以不再定义可变的数组直接用不可变的就可以</span></div><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</div><div class="line"><span class="keyword">let</span> sumNumbers = numbers.<span class="built_in">map</span> &#123; (number: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> number + number</div><div class="line">&#125;</div><div class="line"><span class="comment">// 下面介绍简便写法 因为map闭包里面的类型可以自动推断所以可以省略</span></div><div class="line"><span class="keyword">let</span> sumNumbers1 = numbers.<span class="built_in">map</span> &#123; number <span class="keyword">in</span></div><div class="line">    <span class="keyword">return</span> number + number</div><div class="line">&#125;</div><div class="line"><span class="comment">// 可以省了return 但是循环次数多了一次 目前不知道这是什么原因(循环次数是3次这是4次) 结果是一样的 &lt;如果哪位大神知道麻烦告明小弟&gt;</span></div><div class="line"><span class="keyword">let</span> sumNumbers2 = numbers.<span class="built_in">map</span> &#123; number <span class="keyword">in</span> number + number &#125;</div><div class="line"><span class="built_in">print</span>(sumNumbers2) <span class="comment">// [2,4,6]</span></div><div class="line"><span class="comment">// 最终简化写法</span></div><div class="line"><span class="keyword">let</span> sumNumbers3 = numbers.<span class="built_in">map</span> &#123; $<span class="number">0</span> + $<span class="number">0</span> &#125;</div></pre></td></tr></table></figure>
<hr>
<h4 id="2-Map函数返回数组的元素类型不一定要与原数组相同"><a href="#2-Map函数返回数组的元素类型不一定要与原数组相同" class="headerlink" title="2. Map函数返回数组的元素类型不一定要与原数组相同"></a>2. Map函数返回数组的元素类型不一定要与原数组相同</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">""</span>]</div><div class="line"><span class="comment">// 这里数组中存在一个""的字符串 为了后面来比较 map 和 flatMap</span></div><div class="line"><span class="keyword">let</span> counts = fruits.<span class="built_in">map</span> &#123; fruit -&gt; <span class="type">Int</span>? <span class="keyword">in</span></div><div class="line">    <span class="keyword">let</span> length = fruit.characters.<span class="built_in">count</span></div><div class="line">    <span class="keyword">guard</span> length &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> length</div><div class="line">&#125;</div><div class="line"><span class="comment">// [Optional(5), Optional(6), Optional(6), nil]</span></div><div class="line"><span class="built_in">print</span>(counts)</div></pre></td></tr></table></figure>
<hr>
<h4 id="3-Map还能返回判断数组中的元素是否满足某种条件的Bool值数组"><a href="#3-Map还能返回判断数组中的元素是否满足某种条件的Bool值数组" class="headerlink" title="3. Map还能返回判断数组中的元素是否满足某种条件的Bool值数组"></a>3. Map还能返回判断数组中的元素是否满足某种条件的Bool值数组</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</div><div class="line"><span class="comment">// 最洁简的写法</span></div><div class="line"><span class="keyword">let</span> isEven = array.<span class="built_in">map</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</div><div class="line"><span class="comment">// 这里在写下完成的写法 下面的例子 将都采用最洁简的写法^_^ 同时也要养成习惯看见上面那种洁简的写法 就要懂它做了些什么 会有什么样的结果</span></div><div class="line"><span class="keyword">let</span> isEven1 = array.<span class="built_in">map</span> &#123; num <span class="keyword">in</span></div><div class="line">    <span class="comment">// 写上retrun在Playground中的循环次数是6次 不写是7次 Xcode版本是7.2(7C68) </span></div><div class="line">    <span class="comment">// 不知道这是不是bug 有知道的提醒下我～</span></div><div class="line">    <span class="keyword">return</span> num % <span class="number">2</span> == <span class="number">0</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// [false, true, false, true, false, true]</span></div><div class="line"><span class="built_in">print</span>(isEven)</div></pre></td></tr></table></figure>
<hr>
<h1 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h1><blockquote>
<p>flatMap 与 map 不同之处是<br>flatMap返回后的数组中不存在 nil 同时它会把Optional解包;<br>flatMap 还能把数组中存有数组的数组 一同打开变成一个新的数组 ;<br>flatMap也能把两个不同的数组合并成一个数组 这个合并的数组元素个数是前面两个数组元素个数的乘积</p>
</blockquote>
<h4 id="1-flatMap返回后的数组中不存在nil-同时它会把Optional解包"><a href="#1-flatMap返回后的数组中不存在nil-同时它会把Optional解包" class="headerlink" title="1. flatMap返回后的数组中不存在nil 同时它会把Optional解包"></a>1. flatMap返回后的数组中不存在nil 同时它会把Optional解包</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>, <span class="string">""</span>]</div><div class="line"><span class="keyword">let</span> counts = fruits.flatMap &#123; fruit -&gt; <span class="type">Int</span>? <span class="keyword">in</span></div><div class="line">    <span class="keyword">let</span> length = fruit.characters.<span class="built_in">count</span></div><div class="line">    <span class="keyword">guard</span> length &gt; <span class="number">0</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> length</div><div class="line">&#125;</div><div class="line"><span class="comment">// [5,6,6]</span></div><div class="line"><span class="built_in">print</span>(counts)</div></pre></td></tr></table></figure>
<hr>
<h4 id="2-flatMap-还能把数组中存有数组的数组-一同打开变成一个新的数组-看代码秒懂"><a href="#2-flatMap-还能把数组中存有数组的数组-一同打开变成一个新的数组-看代码秒懂" class="headerlink" title="2. flatMap 还能把数组中存有数组的数组 一同打开变成一个新的数组(看代码秒懂~_~)"></a>2. flatMap 还能把数组中存有数组的数组 一同打开变成一个新的数组(看代码秒懂~_~)</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> array = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]]</div><div class="line"><span class="comment">// 如果用map来获取新的数组</span></div><div class="line"><span class="keyword">let</span> arrayMap = array.<span class="built_in">map</span> &#123; $<span class="number">0</span> &#125;</div><div class="line"><span class="comment">// [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span></div><div class="line"><span class="built_in">print</span>(arrayMap)</div><div class="line"><span class="comment">// 用flatMap</span></div><div class="line"><span class="keyword">let</span> arrayFlatMap = array.flatMap &#123; $<span class="number">0</span> &#125;</div><div class="line"><span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8, 9]</span></div><div class="line"><span class="built_in">print</span>(arrayFlatMap)</div></pre></td></tr></table></figure>
<hr>
<h4 id="3-flatMap也能把两个不同的数组合并成一个数组-这个合并的数组元素个数是前面两个数组元素个数的乘积"><a href="#3-flatMap也能把两个不同的数组合并成一个数组-这个合并的数组元素个数是前面两个数组元素个数的乘积" class="headerlink" title="3. flatMap也能把两个不同的数组合并成一个数组 这个合并的数组元素个数是前面两个数组元素个数的乘积"></a>3. flatMap也能把两个不同的数组合并成一个数组 这个合并的数组元素个数是前面两个数组元素个数的乘积</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这种情况是把两个不同的数组合并成一个数组 这个合并的数组元素个数是前面两个数组元素个数的乘积</span></div><div class="line"><span class="keyword">let</span> fruits = [<span class="string">"apple"</span>, <span class="string">"banana"</span>, <span class="string">"orange"</span>]</div><div class="line"><span class="keyword">let</span> counts = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="keyword">let</span> fruitCounts = counts.flatMap &#123; <span class="built_in">count</span> <span class="keyword">in</span></div><div class="line">    fruits.<span class="built_in">map</span> &#123; fruit <span class="keyword">in</span></div><div class="line"><span class="comment">//        title + "\(index)"</span></div><div class="line">        <span class="comment">// 也可以返回元组</span></div><div class="line">        (fruit, <span class="built_in">count</span>)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// [("apple", 1), ("banana", 1), ("orange", 1), ("apple", 2), ("banana", 2), ("orange", 2), ("apple", 3), ("banana", 3), ("orange", 3)]</span></div><div class="line"><span class="built_in">print</span>(fruitCounts)</div><div class="line"><span class="comment">// 这种方法估计用的很少 可以算是一个 flatMap 和 map 的结合使用吧</span></div></pre></td></tr></table></figure>
<hr>
<h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><blockquote>
<p>filter 可以取出数组中符合条件的元素 重新组成一个新的数组</p>
</blockquote>
<h4 id="filter可以很好的帮我们把数组中不需要的值都去掉-这个很赞！"><a href="#filter可以很好的帮我们把数组中不需要的值都去掉-这个很赞！" class="headerlink" title="filter可以很好的帮我们把数组中不需要的值都去掉 这个很赞！"></a>filter可以很好的帮我们把数组中不需要的值都去掉 这个很赞！</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</div><div class="line"><span class="keyword">let</span> evens = numbers.<span class="built_in">filter</span> &#123; $<span class="number">0</span> % <span class="number">2</span> == <span class="number">0</span> &#125;</div><div class="line"><span class="comment">// [2, 4, 6]</span></div><div class="line"><span class="built_in">print</span>(evens)</div></pre></td></tr></table></figure>
<hr>
<h1 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h1><blockquote>
<p>map,flatMap和filter方法都是通过一个已存在的数组，生成一个新的、经过修改的数组。然而有时候我们需要把所有元素的值合并成一个新的值 那么就用到了Reduce</p>
</blockquote>
<h4 id="1-比如我们要获得一个数组中所有元素的和"><a href="#1-比如我们要获得一个数组中所有元素的和" class="headerlink" title="1. 比如我们要获得一个数组中所有元素的和"></a>1. 比如我们要获得一个数组中所有元素的和</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</div><div class="line"><span class="comment">// reduce 函数第一个参数是返回值的初始化值</span></div><div class="line"><span class="keyword">let</span> sum = numbers.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;</div><div class="line"><span class="comment">// 这里我写下完整的格式</span></div><div class="line"><span class="keyword">let</span> sum1 = numbers.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123; total, num <span class="keyword">in</span></div><div class="line">    <span class="comment">// 这里写不写return在Playground都循环5次 但上面用最洁简的方法显示循环6次。。。 What The Fuck 这是什么鬼！！！</span></div><div class="line">    <span class="keyword">return</span> total + num</div><div class="line">&#125;</div><div class="line"><span class="comment">// 15</span></div><div class="line"><span class="built_in">print</span>(sum)</div></pre></td></tr></table></figure>
<hr>
<h4 id="2-合并成的新值不一定跟原数组中元素的类型相同"><a href="#2-合并成的新值不一定跟原数组中元素的类型相同" class="headerlink" title="2. 合并成的新值不一定跟原数组中元素的类型相同"></a>2. 合并成的新值不一定跟原数组中元素的类型相同</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> numbers = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>]</div><div class="line"><span class="comment">// reduce 函数第一个参数是返回值的初始化值</span></div><div class="line"><span class="keyword">let</span> tel = numbers.<span class="built_in">reduce</span>(<span class="string">""</span>) &#123; <span class="string">"<span class="subst">\($<span class="number">0</span>)</span>"</span> + <span class="string">"<span class="subst">\($<span class="number">1</span>)</span>"</span> &#125;</div><div class="line"><span class="comment">// 15188888888</span></div><div class="line"><span class="built_in">print</span>(tel)</div></pre></td></tr></table></figure>
<hr>
<h4 id="3-ruduce-还可以实现-map-和-filter-并且时间复杂度变为O-n-原来-map-和-filter-的时间复杂度是O-n-n"><a href="#3-ruduce-还可以实现-map-和-filter-并且时间复杂度变为O-n-原来-map-和-filter-的时间复杂度是O-n-n" class="headerlink" title="3. ruduce 还可以实现 map 和 filter 并且时间复杂度变为O(n) 原来 map 和 filter 的时间复杂度是O(n*n)"></a>3. ruduce 还可以实现 map 和 filter 并且时间复杂度变为O(n) 原来 map 和 filter 的时间复杂度是O(n*n)</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mMap</span>&lt;U&gt; <span class="params">(transform: Element -&gt; U)</span></span> -&gt; [<span class="type">U</span>] &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">reduce</span>([], combine: &#123; $<span class="number">0</span> + [transform($<span class="number">1</span>)] &#125;)</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">mFilter</span> <span class="params">(includeElement: Element -&gt; Bool)</span></span> -&gt; [<span class="type">Element</span>] &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">reduce</span>([]) &#123; includeElement($<span class="number">1</span>) ? $<span class="number">0</span> + [$<span class="number">1</span>] : $<span class="number">0</span> &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>本人对泛型的研究还很浅显，后续我会写一篇关于Swift范型的文章</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;map函数能够被数组调用，它接受一个闭包作为参数，作用于数组中的每个元素。闭包返回一个变换后的元素，接着将
    
    </summary>
    
    
      <category term="Swift" scheme="http://MelodyZhy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发中本地数据存储的总结</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/iOS%E5%BC%80%E5%8F%91%E4%B8%AD%E6%9C%AC%E5%9C%B0%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%9A%84%E6%80%BB%E7%BB%93/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/iOS开发中本地数据存储的总结/</id>
    <published>2017-08-01T10:52:21.000Z</published>
    <updated>2017-08-01T10:53:33.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<h4 id="iOS开发中本地存储主要有三种形式"><a href="#iOS开发中本地存储主要有三种形式" class="headerlink" title="iOS开发中本地存储主要有三种形式"></a>iOS开发中本地存储主要有三种形式</h4></blockquote>
<ul>
<li>XML属性列表(plist)归档</li>
<li>Preference(偏好设置)</li>
<li>NSKeyedArchiver归档(NSCoding)</li>
</ul>
<blockquote>
<h4 id="应用沙盒"><a href="#应用沙盒" class="headerlink" title="应用沙盒"></a>应用沙盒</h4></blockquote>
<h5 id="什么是应用沙盒"><a href="#什么是应用沙盒" class="headerlink" title="什么是应用沙盒"></a>什么是应用沙盒</h5><p>要想在本地存储数据，那就要知道一下什么是<strong>应用沙盒 </strong>,其实很好理解应用沙盒就是应用的文件夹，与其他文件系统隔离。每一个iOS应用都有自己的应用沙盒，应用必须待在自己的沙盒里，其它应用不能访问该沙盒。<br>如何获取应用沙盒路径，可以通过打印NSHomeDirectory()来获取应用沙盒路径，下图为打印路径结果：</p>
<p>屏幕快照 2015-12-03 22.10.07.png</p>
<p>Melody_Zhy 是用户文件夹(样子是个小房子)<br>3CEC8EEB-C230-44BE-93B7-DF3B9A120A94 iOS8之后每次运行Xcode都会生成不同的沙盒路径，不同之处就是最后这个文件夹名，可能是苹果为了安全着想</p>
<hr>
<h5 id="应用沙盒结构分析"><a href="#应用沙盒结构分析" class="headerlink" title="应用沙盒结构分析"></a>应用沙盒结构分析</h5><p>首先我们先来看下，应用沙盒里面都有什么</p>
<p>屏幕快照 2015-12-03 22.27.50.png</p>
<p>这里提一下Finder的快捷键 shift ＋ com ＋ g 可以前往任意路径的文件夹，因此我们可以打印沙盒路径之后将沙盒路径复制到Finder前往路径文件夹中，前往应用沙盒。这是一个比较耽误事的方法！幸好有一款叫做simpholders的app，它可以很简单的访问应用的沙盒路径，记得去下载simpholders2哦，第一代iOS8之后就不能用了，app很简单易懂，用下就会了～<br>现在我们来看看应用沙盒里面这些文件夹都是做什么用的</p>
<ul>
<li><strong>Documents</strong> ：保存应用运行时生成的<strong>需要持久化的数据</strong>，iTunes同步设备时<strong>会备份</strong>该目录。例如，游戏应用可将游戏存档保存在该目录</li>
<li><strong>Library/Caches</strong> : 保存应用运行时生成的<strong>需要持久化的数据</strong>，iTunes同步设备时<strong>不会备份</strong>该目录。一般存储体积大、不需要备份的非重要数据</li>
<li><strong>Library/Preference</strong> : 保存应用的所有<strong>偏好设置</strong>，iOS的Settings(设置)应用会在该目录中查找应用的设置信息。iTunes同步设备时<strong>会备份</strong>该目录</li>
<li><strong>tmp</strong> : 保存应用运行时所需的<strong>临时数据</strong>，使用完毕后再将相应的文件从该目录删除。应用没有运行时，系统也可能会清除该目录下的文件。iTunes同步设备时<strong>不会备份</strong>该目录</li>
</ul>
<blockquote>
<h4 id="应用沙盒目录的常见获取方式"><a href="#应用沙盒目录的常见获取方式" class="headerlink" title="应用沙盒目录的常见获取方式"></a>应用沙盒目录的常见获取方式</h4></blockquote>
<h5 id="沙盒根目录的获取方式"><a href="#沙盒根目录的获取方式" class="headerlink" title="沙盒根目录的获取方式"></a>沙盒根目录的获取方式</h5><p>正如上面我们所说：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *home = NSHomeDirectory();</div></pre></td></tr></table></figure>
<h5 id="Documents文件夹的获取方式（3种）"><a href="#Documents文件夹的获取方式（3种）" class="headerlink" title="Documents文件夹的获取方式（3种）"></a>Documents文件夹的获取方式（3种）</h5><p><strong>第一种（ ！笨！）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 利用沙盒根目录拼接字符串</div><div class="line">NSString *homePath = NSHomeDirectory();</div><div class="line">NSString *docPath = [homePath stringByAppendingString:@&quot;/Documents&quot;];</div></pre></td></tr></table></figure>
<p><strong>第二种（ ！还👌！）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 利用沙盒根目录拼接”Documents”字符串</div><div class="line">NSString *homePath = NSHomeDirectory();</div><div class="line">NSString *docPath = [homePath stringByAppendingPathComponent:@&quot;Documents&quot;];</div></pre></td></tr></table></figure>
<p>但是不建议使用这种方法，因为不定哪天苹果大大就把文件名称改了呢-_-!</p>
<p><strong>第三种（ ！~推荐~ ！）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// NSDocumentDirectory 要查找的文件</div><div class="line">// NSUserDomainMask 代表从用户文件夹下找</div><div class="line">// 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素</div><div class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];</div><div class="line">NSString *filePath = [path stringByAppendingPathComponent:@&quot;xxx.plist&quot;];</div></pre></td></tr></table></figure>
<p>这里我来详细的说下NSSearchPathForDirectoriesInDomains这个方法的几个参数 ：<br>&lt;#NSSearchPathDirectory directory#&gt; 这个参数代表要查找的文件，是个枚举！ 枚举你懂的点击去看看就知道了～<br>&lt;#NSSearchPathDomainMask domainMask#&gt; 这个参数代表从用户文件夹下找，也是枚举！<br>最后一个参数如果是NO的话，打印的路径会是这种形式~/Documents，我们一般都会用YES，这样可以获取完整路径字符串！<br>这个方法的返回值是一个数组，但在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素，所以我们取第一个元素！</p>
<hr>
<h5 id="Library-Caches文件夹的获取方式（跟上面的方法相似）"><a href="#Library-Caches文件夹的获取方式（跟上面的方法相似）" class="headerlink" title="Library/Caches文件夹的获取方式（跟上面的方法相似）"></a>Library/Caches文件夹的获取方式（跟上面的方法相似）</h5><p>这里我只用上面的第三种方法！注意第一个参数！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];</div><div class="line">NSString *filePath = [path stringByAppendingPathComponent:@&quot;student.data&quot;];</div></pre></td></tr></table></figure>
<hr>
<h5 id="tmp文件夹的获取方式"><a href="#tmp文件夹的获取方式" class="headerlink" title="tmp文件夹的获取方式"></a>tmp文件夹的获取方式</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSString *tmp= NSTemporaryDirectory();</div></pre></td></tr></table></figure>
<hr>
<h5 id="Library-Preference文件夹的获取方式"><a href="#Library-Preference文件夹的获取方式" class="headerlink" title="Library/Preference文件夹的获取方式"></a>Library/Preference文件夹的获取方式</h5><p>通过NSUserDefaults类存取该目录下的设置信息!<br><strong>!!!这个下面会有介绍!!!</strong></p>
<blockquote>
<h4 id="XML属性列表（plist）归档"><a href="#XML属性列表（plist）归档" class="headerlink" title="XML属性列表（plist）归档"></a>XML属性列表（plist）归档</h4></blockquote>
<h5 id="plist文件"><a href="#plist文件" class="headerlink" title="plist文件"></a>plist文件</h5><p>plist的根Type只能是字典（NSDictionary）或者是数组（NSArray）所以归档时我们只能将数组或字典保存到plist文件中，但是NSString也能通过归档保存到plist文件中同时它也可以通过stringWithContentsOfFile解档，它保存到plist中时Type是空的，Value是有值的！</p>
<hr>
<h5 id="plist文件的归档"><a href="#plist文件的归档" class="headerlink" title="plist文件的归档"></a>plist文件的归档</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">NSArray *arr = [[NSArray alloc] initWithObjects:@&quot;1&quot;, @&quot;2&quot;, nil];</div><div class="line">// NSDocumentDirectory 要查找的文件</div><div class="line">// NSUserDomainMask 代表从用户文件夹下找</div><div class="line">// 在iOS中，只有一个目录跟传入的参数匹配，所以这个集合里面只有一个元素</div><div class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];</div><div class="line">NSString *filePath = [path stringByAppendingPathComponent:@&quot;xxx.plist&quot;];</div><div class="line">[arr writeToFile:filePath atomically:YES];</div></pre></td></tr></table></figure>
<h5 id="plist文件的解档"><a href="#plist文件的解档" class="headerlink" title="plist文件的解档"></a>plist文件的解档</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSString *filePath = [path stringByAppendingPathComponent:@&quot;xxx.plist&quot;];</div><div class="line">// 解档</div><div class="line">NSArray *arr = [NSArray arrayWithContentsOfFile:filePath];</div><div class="line">NSLog(@&quot;%@&quot;, arr);</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="Preference-偏好设置"><a href="#Preference-偏好设置" class="headerlink" title="Preference(偏好设置)"></a>Preference(偏好设置)</h4></blockquote>
<p>OC中有一个NSUserDefaults的单例，它可以用来存储用户的偏好设置，例如：用户名，字体的大小，用户的一些设置等，下面我用两个UISwitch来演示如何保存用户设置开关的关闭状态</p>
<hr>
<h5 id="保存用户偏好设置"><a href="#保存用户偏好设置" class="headerlink" title="保存用户偏好设置"></a>保存用户偏好设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 获取用户偏好设置对象</div><div class="line">NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];</div><div class="line">// 保存用户偏好设置</div><div class="line">[defaults setBool:self.one.isOn forKey:@&quot;one&quot;];</div><div class="line">[defaults setBool:self.two.isOn forKey:@&quot;two&quot;];</div><div class="line">// 注意：UserDefaults设置数据时，不是立即写入，而是根据时间戳定时地把缓存中的数据写入本地磁盘。所以调用了set方法之后数据有可能还没有写入磁盘应用程序就终止了。</div><div class="line">// 出现以上问题，可以通过调用synchornize方法强制写入</div><div class="line">// 现在这个版本不用写也会马上写入 不过之前的版本不会</div><div class="line">[defaults synchronize];</div></pre></td></tr></table></figure>
<h5 id="读取用户偏好设置"><a href="#读取用户偏好设置" class="headerlink" title="读取用户偏好设置"></a>读取用户偏好设置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 读取用户偏好设置</div><div class="line">NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults]; </div><div class="line">self.one.on = [defaults boolForKey:@&quot;one&quot;];</div><div class="line">self.two.on = [defaults boolForKey:@&quot;two&quot;];</div></pre></td></tr></table></figure>
<blockquote>
<h4 id="NSKeyedArchiver归档-NSCoding"><a href="#NSKeyedArchiver归档-NSCoding" class="headerlink" title="NSKeyedArchiver归档(NSCoding)"></a>NSKeyedArchiver归档(NSCoding)</h4></blockquote>
<p>只有遵守了NSCoding协议的类才可以用NSKeyedArchiver归档和NSKeyedUnarchiver解档，如果对象是NSString、NSDictionary、NSArray、NSData、NSNumber等类型，可以直接用NSKeyedArchiver归档和NSKeyedUnarchiver解档～<br>下面我举的🌰是归档解档一个Student模型，因此该模型应该遵守NSCoding协议</p>
<hr>
<h5 id="实现encodeWithCoder和initWithCoder方法"><a href="#实现encodeWithCoder和initWithCoder方法" class="headerlink" title="实现encodeWithCoder和initWithCoder方法"></a>实现encodeWithCoder和initWithCoder方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">- (void)encodeWithCoder:(NSCoder *)coder</div><div class="line">&#123;</div><div class="line">[coder encodeObject:self.name forKey:@&quot;name&quot;];</div><div class="line">[coder encodeInteger:self.age forKey:@&quot;age&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (instancetype)initWithCoder:(NSCoder *)coder</div><div class="line">&#123;</div><div class="line">self = [super init];</div><div class="line">if (self) &#123;</div><div class="line">    self.age = [coder decodeIntegerForKey:@&quot;age&quot;];</div><div class="line">    self.name = [coder decodeObjectForKey:@&quot;name&quot;];</div><div class="line">&#125;</div><div class="line">return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="归档"><a href="#归档" class="headerlink" title="归档"></a>归档</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Student *s1 = [[Student alloc] init];</div><div class="line">s1.name = @&quot;zzz&quot;;</div><div class="line">s1.age = 18;</div><div class="line"></div><div class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];</div><div class="line">// 这个文件后缀可以是任意的，只要不与常用文件的后缀重复即可，我喜欢用data</div><div class="line">NSString *filePath = [path stringByAppendingPathComponent:@&quot;student.data&quot;];</div><div class="line">// 归档</div><div class="line">[NSKeyedArchiver archiveRootObject:s1 toFile:filePath];</div></pre></td></tr></table></figure>
<h5 id="解档"><a href="#解档" class="headerlink" title="解档"></a>解档</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)[0];</div><div class="line">NSString *filePath = [path stringByAppendingPathComponent:@&quot;student.data&quot;];</div><div class="line">// 解档</div><div class="line">Student *s = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath];</div><div class="line">NSLog(@&quot;%@----%ld&quot;, s.name, s.age);</div></pre></td></tr></table></figure>
<hr>
<p>这就是我想到的iOS开发中本地数据存储的几种方式，希望对大家有帮助～</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;h4 id=&quot;iOS开发中本地存储主要有三种形式&quot;&gt;&lt;a href=&quot;#iOS开发中本地存储主要有三种形式&quot; class=&quot;headerlink&quot; title=&quot;iOS开发中本地存储主要有三种形式&quot;&gt;&lt;/a&gt;iOS开发中本地存储主要有三种形式&lt;/h4&gt;
    
    </summary>
    
    
      <category term="iOS存储相关" scheme="http://MelodyZhy.github.io/tags/iOS%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>瀑布流框架的搭建</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/%E7%80%91%E5%B8%83%E6%B5%81%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/瀑布流框架的搭建/</id>
    <published>2017-08-01T10:46:04.000Z</published>
    <updated>2017-08-01T10:47:44.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>瀑布流大家都应该熟悉了，现在大部分电商应用中或多或少的都用到瀑布流，它可以吸引用户的眼球，使用户不易产生视觉疲劳，苹果在iOS6中增添了UICollectionView控件，这个控件可以说是UITableView的升级版，通过这个控件我们就能很简单的做出瀑布流，后面通过自己的封装可以让其变成一个小框架，更简单的应用到我们之后的开发中</p>
</blockquote>
<p>如果想做瀑布流，那么就要自定义CollectionViewFlowLayout,因为这个类中有一个返回collectionView中所有子控件的布局属性（布局属性中有控件的frame和索引）的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> - (NSArray&lt;UICollectionViewLayoutAttributes *&gt; )layoutAttributesForElementsInRect:(CGRect)rect &#123;</div><div class="line">   NSArray arr = [super layoutAttributesForElementsInRect:rect];</div><div class="line">   for (UICollectionViewLayoutAttributes *attri in arr) &#123;</div><div class="line">       attri.frame = CGRectMake(0, 0, 100, 300);</div><div class="line">   &#125;</div><div class="line">   NSLog(@&quot;%@&quot;, arr);</div><div class="line">   return arr;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法会将collectionView中的所有子控件的布局属性计算一次，计算之后就会被缓存起来，当已经计算过的cell，再次出现时也不会在重复去计算它的尺寸。<br>注意：如果要进行刷新数据那么要记得将之前的布局属性进行清空，不然会出现布局错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 把用来装所有布局属性的数据做清空处理</div><div class="line">[self.attrArrM removeAllObjects];</div></pre></td></tr></table></figure>
<p>现在定义一个可变数组属性来存储一会自己计算的布局属性中的frame，让上面的方法返回自己定义的布局属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 用来保存所有布局属性的可变数组</div><div class="line">@property (nonatomic, strong) NSMutableArray *attrArrM;</div></pre></td></tr></table></figure>
<p>那么我们在哪个方法中计算自己定义的布局属性呢？<br>有这么个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> - (void)prepareLayout &#123;</div><div class="line">// 要调用父类的prepareLayout</div><div class="line">    [super prepareLayout];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="当collectionView中的所有子控件即将显示的时候就会来调用此方法做布局前的准备工作，准备itemSize…等等属性-同时当布局的属性发生变化时也会来调用此方法-当刷新数据之后也会来调用此方法重新做布局前的准备工作"><a href="#当collectionView中的所有子控件即将显示的时候就会来调用此方法做布局前的准备工作，准备itemSize…等等属性-同时当布局的属性发生变化时也会来调用此方法-当刷新数据之后也会来调用此方法重新做布局前的准备工作" class="headerlink" title="当collectionView中的所有子控件即将显示的时候就会来调用此方法做布局前的准备工作，准备itemSize…等等属性 同时当布局的属性发生变化时也会来调用此方法 当刷新数据之后也会来调用此方法重新做布局前的准备工作"></a>当collectionView中的所有子控件即将显示的时候就会来调用此方法做布局前的准备工作，准备itemSize…等等属性 同时当布局的属性发生变化时也会来调用此方法 当刷新数据之后也会来调用此方法重新做布局前的准备工作</h4><p>在这个方法中可以通过collectionViewFlowLayout的collectionView的numberOfItemInSection这个方法获得一组中的所有cell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 获得一组中的所有cell</div><div class="line">NSInteger cellCount = [self.collectionView numberOfItemsInSection:0];</div></pre></td></tr></table></figure>
<p>通过for循环（循环次数为一组中有多少个cell）创建布局属性，在循环中需要计算每一个cell的frame 所以后台要给真实的图片尺寸（如果不给，自己计算的尺寸会造成图片闪）<br>同时显示时一般都会等比例缩放。</p>
<h3 id="cell宽度的计算"><a href="#cell宽度的计算" class="headerlink" title="cell宽度的计算"></a>cell宽度的计算</h3><h5 id="cell的宽-＝-内容的宽-列数-1-最小间距-列数"><a href="#cell的宽-＝-内容的宽-列数-1-最小间距-列数" class="headerlink" title="cell的宽 ＝ (内容的宽 - (列数 - 1) * 最小间距) / 列数"></a>cell的宽 ＝ (内容的宽 - (列数 - 1) * 最小间距) / 列数</h5><h5 id="内容的宽-collectionView的宽-组的左边间距-右边间距"><a href="#内容的宽-collectionView的宽-组的左边间距-右边间距" class="headerlink" title="内容的宽 = collectionView的宽 - 组的左边间距 - 右边间距"></a>内容的宽 = collectionView的宽 - 组的左边间距 - 右边间距</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">CGFloat contentWidth = self.collectionView.bounds.size.width - self.sectionInset.left - self.sectionInset.right;</div><div class="line">CGFloat cellW = (contentWidth - (self.columnCount - 1) * self.minimumInteritemSpacing) / self.columnCount;</div></pre></td></tr></table></figure>
<h3 id="cell高度的获取"><a href="#cell高度的获取" class="headerlink" title="cell高度的获取"></a>cell高度的获取</h3><p>当要获得cell高的时候需要通过控制器来获得模型图片的高度（高度要和itemW有一定的比例要不图片会过大 height / width * itemW;），因此需要让控制器成为我们的代理，在自定义CollectionViewFlowLayout.h文件中定义协议如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">@class ZHYCollectionViewFlowLayout;</div><div class="line">@protocol ZHYCollectionViewFlowLayoutDelegate &lt;NSObject&gt;</div><div class="line">@required</div><div class="line">- (CGFloat)waterFallFlowLayoutWithItemHeight:(ZHYCollectionViewFlowLayout )flowLayout itemW:(CGFloat)itemW CellIndexPath:(NSIndexPath )indexPath;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>并且设置代理属性如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (weak, nonatomic) id&lt;ZHYCollectionViewFlowLayoutDelegate&gt; delegate</div></pre></td></tr></table></figure>
<p>在计算cell高的时候调用代理方法获得cell的高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGFloat cellH = [self.delegate waterFallFlowLayoutWithItemHeight:self itemW:cellW CellIndexPath:indexPath];</div></pre></td></tr></table></figure>
<p>为什么要在代理方法中加入indexPath，因为要通过indexPath来获取模型</p>
<h3 id="cellX的计算"><a href="#cellX的计算" class="headerlink" title="cellX的计算"></a>cellX的计算</h3><p>在计算cellX的时候<br>如果通过 NSInteger col = i % self.columnCount;获取列号要注意一个问题:<br>这样每次都是按顺序排列图片的，那么如果图片的尺寸参差不齐有的特别短有的又特别长，不巧的是长的都在一列短的又都在一列这样会造成美观性会很差，那么怎么解决这个问题呢，我们能不能让每一行添加完毕后，下一行在添加的时候将第一个添加在上一行高度最短的那面图片下面呢？答案当然是可以的-_-!<br>这时候我们就要定义一个可变字典属性，来存储每一列的高度，用列号来当字典的key</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 用来记录每一列的最的高度</div><div class="line">@property (nonatomic, strong) NSMutableDictionary *colDict;</div></pre></td></tr></table></figure>
<p>在prepareLayout方法中给每一列的高度的字典一个默认的高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for (NSInteger i = 0; i&lt;有几列; i++) &#123;</div><div class="line">       NSString *str = [NSString stringWithFormat:@&quot;%ld&quot;, i];</div><div class="line">       self.colDict[str] = @(self.sectionInset.top);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>获得最矮的那一列列号的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (NSString )minCol &#123;</div><div class="line">   __block NSString min = @&quot;0&quot;;</div><div class="line">   [self.colDict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123;</div><div class="line">       if ([obj floatValue] &lt; [self.colDict[min] floatValue]) &#123;</div><div class="line">           min = key;</div><div class="line">       &#125;</div><div class="line">   &#125;];</div><div class="line">   return min;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因此列号为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSInteger col = [[self minCol] integerValue];</div></pre></td></tr></table></figure>
<p>cellX为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CGFloat cellX = self.sectionInset.left + (cellW + self.minimumInteritemSpacing) * col;</div></pre></td></tr></table></figure>
<h3 id="cellY的计算"><a href="#cellY的计算" class="headerlink" title="cellY的计算"></a>cellY的计算</h3><p>计算cellY</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 用列号当字典的key</div><div class="line">NSString *colStr = [NSString stringWithFormat:@&quot;%ld&quot;, col];</div><div class="line">CGFloat cellY = [self.colDict[colStr] floatValue];</div><div class="line">// 累计每一列的高度</div><div class="line">self.colDict[colStr] = @(cellY + cellH + self.minimumLineSpacing);</div></pre></td></tr></table></figure>
<p>这样我们就计算完了每一个cell的X,Y,W,H,我们来设置布局属性的frame</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 设置属性的frame</div><div class="line">attr.frame = CGRectMake(cellX, cellY, cellW, cellH);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 创建尾部视图的布局属性</div><div class="line">   // 创建footerview索引</div><div class="line">   NSIndexPath indexPath = [NSIndexPath indexPathForItem:0 inSection:0];</div><div class="line">   // 必须是额外的layoutAttributesForSupplementaryViewOfKind</div><div class="line">   UICollectionViewLayoutAttributes footerAttr = [UICollectionViewLayoutAttributes layoutAttributesForSupplementaryViewOfKind: UICollectionElementKindSectionFooter withIndexPath:indexPath];</div><div class="line">   footerAttr.frame = CGRectMake(0, [self.colDict[self.maxCol] floatValue] - self.minimumLineSpacing, self.collectionView.bounds.size.width, 50);</div><div class="line">   [self.attrArrM addObject:footerAttr];</div></pre></td></tr></table></figure>
<p>这里要用到最高列，因为尾部视图要放在cell最下面，获得最高列索引的方法为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 用来取出最高那一列的列号</div><div class="line">- (NSString )maxCol &#123;</div><div class="line">   __block NSString maxCol = @&quot;0&quot;;</div><div class="line">   [self.colDict enumerateKeysAndObjectsUsingBlock:^(id _Nonnull key, id _Nonnull obj, BOOL * _Nonnull stop) &#123;</div><div class="line">       if ([obj floatValue] &gt; [self.colDict[maxCol] floatValue]) &#123;</div><div class="line">           maxCol = key;</div><div class="line">       &#125;</div><div class="line">   &#125;];</div><div class="line">   return maxCol;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们通过上面说过的方法把布局属性返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (NSArray&lt;UICollectionViewLayoutAttributes *&gt; *)layoutAttributesForElementsInRect:(CGRect)rect &#123;</div><div class="line">   return self.attrArrM;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="自定义布局属性的时候还要注意返回真实的contentSize，代码如下："><a href="#自定义布局属性的时候还要注意返回真实的contentSize，代码如下：" class="headerlink" title="自定义布局属性的时候还要注意返回真实的contentSize，代码如下："></a>自定义布局属性的时候还要注意返回真实的contentSize，代码如下：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (CGSize)collectionViewContentSize &#123;</div><div class="line">   return CGSizeMake(0, [self.colDict[self.maxCol] floatValue] + self.footerReferenceSize.height - self.minimumLineSpacing);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这时基本已经完成了，但如果我想要把这个瀑布流布局做成一个简单的框架就需要在简单的实现些初始化方法<br>在CollectionViewFlowLayout.h还要定义一个一行有几个cell的属性，当控制器引用这个类之后可以自行设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (assign, nonatomic) NSInteger columnCount;</div></pre></td></tr></table></figure>
<p>提供一些初始化方法，使其默认为一行有3个cell， cell间距及行间距为10，内边距为顶部20， footerReferenceSize， headerReferenceSize都为50，50</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (instancetype)init</div><div class="line">&#123;</div><div class="line">   self = [super init];</div><div class="line">   if (self) &#123;</div><div class="line">       self.columnCount = 3;</div><div class="line">       self.minimumInteritemSpacing = 10;</div><div class="line">       self.minimumLineSpacing = 10;</div><div class="line">       self.footerReferenceSize = CGSizeMake(50, 50);</div><div class="line">       self.headerReferenceSize = CGSizeMake(50, 50);</div><div class="line">       self.sectionInset = UIEdgeInsetsMake(20, 0, 0, 0);</div><div class="line">   &#125;</div><div class="line">   return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (instancetype)initWithCoder:(NSCoder *)aDecoder</div><div class="line">&#123;</div><div class="line">   self = [super initWithCoder:aDecoder];</div><div class="line">   if (self) &#123;</div><div class="line">       self.columnCount = 3;</div><div class="line">       self.minimumInteritemSpacing = 10;</div><div class="line">       self.minimumLineSpacing = 10;</div><div class="line">       self.footerReferenceSize = CGSizeMake(50, 50);</div><div class="line">       self.headerReferenceSize = CGSizeMake(50, 50);</div><div class="line">       self.sectionInset = UIEdgeInsetsMake(20, 0, 0, 0);</div><div class="line">   &#125;</div><div class="line">   return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们简单的瀑布流框架就搭建成功了～</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;瀑布流大家都应该熟悉了，现在大部分电商应用中或多或少的都用到瀑布流，它可以吸引用户的眼球，使用户不易产生视觉疲劳，苹果在iOS6中增添了UICollectionView控件，这个控件可以说是UITableView的升级版，通过这个控件我们就能很简单
    
    </summary>
    
    
      <category term="UI" scheme="http://MelodyZhy.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>UIScorllView和UIPageControl的使用实现图片轮播器</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/UIScorllView%E5%92%8CUIPageControl%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E5%99%A8/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/UIScorllView和UIPageControl的使用实现图片轮播器/</id>
    <published>2017-08-01T07:31:06.000Z</published>
    <updated>2017-08-01T07:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先我们要先建一个project，选择iOS下的第一个Application 中的Single View Application</p>
<p>开始工作已经准备完毕现在我们进入到Main.storyboard拖控件</p>
<p><strong>需要用到的控件有</strong></p>
<ul>
<li>UIScrollView也就是滚动的那个</li>
<li>UIPageControl也就是图片下面那几个小点</li>
<li>NSTimer就是定时器让其自动换页的</li>
</ul>
<p><strong>第一步：拖控件连线</strong></p>
<ul>
<li>在Main.storyboard拖一个UIScrollView放在屏幕上，在UIScrollView下面放一个UIPageControl（注意是下面而不是在UIscrollView上放，如果放到UIScrollView上将看不到UIPageControl）</li>
<li>进行连线，将其连到ViewController.m中的@interface ViewController () 和@end中间</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">@interface ViewController ()</div><div class="line">@property (weak, nonatomic) IBOutlet UIScrollView *scrollView;</div><div class="line">@property (weak, nonatomic) IBOutlet UIPageControl *pageControl;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><strong>第二步：</strong>下面我们要在ViewDidLod中把一个UIImageView加到scrollView中。同时我们要将5张图片放到Images.xcassets中，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 广告图片总数</div><div class="line">int count = 5;</div><div class="line">CGSize size = self.scrollView.frame.size;</div><div class="line">for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">    NSString *imageName = [NSString stringWithFormat:@&quot;img_%02d&quot;, i + 1];</div><div class="line">    UIImage *image = [UIImage imageNamed:imageName];</div><div class="line">    UIImageView *iconView = [[UIImageView alloc] initWithImage:image];</div><div class="line">    [self.scrollView addSubview:iconView];</div><div class="line">    // 设置frame</div><div class="line">    CGFloat x = i * size.width;</div><div class="line">    iconView.frame = CGRectMake(x, 0, size.width, size.height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里要注意的就是5个UIimageView的尺寸，宽和高都一样，唯独不一样的就是他的X，需要1张1张图片往后排</p>
<p><strong>第三步：</strong>设置scrollView的滚动范围以及设置分页，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 设置滚动范围</div><div class="line">self.scrollView.contentSize = CGSizeMake(count * size.width, 0);</div><div class="line">// 滚动条不显示</div><div class="line">self.scrollView.showsHorizontalScrollIndicator = NO;</div><div class="line">self.scrollView.showsVerticalScrollIndicator = NO;</div><div class="line">// 设置分页</div><div class="line">self.scrollView.pagingEnabled = YES;</div><div class="line">// 设置pagecontrol</div><div class="line">self.pageControl.numberOfPages = count;</div></pre></td></tr></table></figure>
<p>上面代码中滚动条不显示那两行代码是因为UIScrollView默认是有横竖滚动条的，那两行代码分别让水平的和竖直的的滚动条不显示，一定要让scrollView设置分页否则那个分页器不会跟着走，最后设置pageControl的页数</p>
<p>第四步：设置scorllView的代理，代理大家都应该熟悉了把，首先要在@interface ViewController ()后面遵循代理 代码如下<br>@interface ViewController () <uiscrollviewdelegate><br>然后在ViewDidLod中设置谁遵循这个代理 那当然是ViewController了 代码如下</uiscrollviewdelegate></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 设置代理</div><div class="line">self.scrollView.delegate = self;</div></pre></td></tr></table></figure>
<p>好了下面开始实现UIScrollView的代理方法了<br>我们需要用的代理的方法有3个分别是</p>
<ol>
<li>- (void)scrollViewDidScroll:(UIScrollView *)scrollView</li>
<li>- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView</li>
<li>- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</li>
</ol>
<p>第一个是scrollView滚动时调用的方法，第二个是开始拖拽时调用的方法， 第三个是结束拖拽时调用的方法</p>
<p>首先我们先想scrollView滚动时是不是拖拽到一半以上松手就能到下一张图片，答案肯定是的。那么就来写这个方法，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 正在滚动时</div><div class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView</div><div class="line">&#123;</div><div class="line">    int page = (scrollView.contentOffset.x + scrollView.frame.size.width / 2) / scrollView.frame.size.width;</div><div class="line">    self.pageControl.currentPage = page;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里计算page页数用到了我们非常熟悉的把一个数 / 多少得到的数  比如112 / 10 等于多少 很明显是 11 这样就能很好通过尺寸把该显示的页面算出来，对了忘了说contentOffset是什么意思了，这个就可以理解为是拖拽的距离</p>
<p><strong>第五步：</strong>现在要实现定时器功能了，让其自动翻页，首先要在@interface ViewController () @end中定义一个定时器timer 代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, strong) NSTimer *timer;</div></pre></td></tr></table></figure>
<p>有人会问为什么要定义这个，因为后面不止一方法需要用到这个timer</p>
<p>定义一个定时器方法，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)addTimer</div><div class="line">&#123;</div><div class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(nextImage) userInfo:nil repeats:YES];</div><div class="line">    self.timer = timer;</div><div class="line">    // 消息循环</div><div class="line">    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">    [runLoop addTimer:timer forMode:NSRunLoopCommonModes];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是一个定时器的方法，里面创建了定时器，并加入了消息循环中，这里面要设置定时器2s之后应该执行哪个方法，很显然要让它2s之后进行翻页啊，那么我们就来写下这个方法nextImage，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- (void)nextImage</div><div class="line">&#123;</div><div class="line">    // 当前页码</div><div class="line">    NSInteger page = self.pageControl.currentPage;</div><div class="line">    if (page == self.pageControl.numberOfPages - 1) &#123;</div><div class="line">        page = 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        page++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CGFloat offsetX = page * self.scrollView.frame.size.width;</div><div class="line">    [UIView animateWithDuration:1.0 animations:^&#123;</div><div class="line">        self.scrollView.contentOffset = CGPointMake(offsetX, 0);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个方法中首先先定义一个page来保存当前的page，然后进行判断如果是最后一张要将页面换成0（这个并不完美会直接从最后一张往回到第一张，但我学习视频的那个老师没有给出解决方法）其他的进行page加1 设置完page数那么我们需要让其自动滚动啊，那我们就来设置scrollView的offset，定义offsetX 等于page数乘以scrollView的宽度，这样正好能移动到下一个视图，同时给移动加一个动画</p>
<p>之后在ViewDidLod中调用此方法，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[self addTimer];</div></pre></td></tr></table></figure>
<p><strong>第六步：</strong>下面来到UIScrollView的代理方法中，其中还有两个代理方法我们没有实现，就是开始拖拽和结束拖拽的方法，代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 开始拖拽的时候调用</div><div class="line">- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView</div><div class="line">&#123;</div><div class="line">    // 停止定时器</div><div class="line">    [self.timer invalidate];</div><div class="line">&#125;</div><div class="line">// 结束拖拽的时候调用</div><div class="line">- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</div><div class="line">&#123;</div><div class="line">    [self addTimer];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里的开始拖拽是要把定时器停止，不然你拖拽不动也会翻页，所有要把定时器停止，把定时器停止了，那我们要向让其在动起来，那么就要让其在开启，要在结束拖拽时开始定时器。</p>
<p>如果你到这一步了，那么恭喜你的图片轮播器就做好了！</p>
<p><strong>完整代码如下</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line"></div><div class="line">@interface ViewController () &lt;UIScrollViewDelegate&gt;</div><div class="line">@property (weak, nonatomic) IBOutlet UIScrollView *scrollView;</div><div class="line">@property (weak, nonatomic) IBOutlet UIPageControl *pageControl;</div><div class="line"></div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // 广告图片总数</div><div class="line">    int count = 5;</div><div class="line">    CGSize size = self.scrollView.frame.size;</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        NSString *imageName = [NSString stringWithFormat:@&quot;img_%02d&quot;, i + 1];</div><div class="line">        UIImage *image = [UIImage imageNamed:imageName];</div><div class="line">        UIImageView *iconView = [[UIImageView alloc] initWithImage:image];</div><div class="line">        [self.scrollView addSubview:iconView];</div><div class="line">        // 设置frame</div><div class="line">        CGFloat x = i * size.width;</div><div class="line">        iconView.frame = CGRectMake(x, 0, size.width, size.height);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 设置滚动范围</div><div class="line">    self.scrollView.contentSize = CGSizeMake(count * size.width, 0);</div><div class="line">    // 滚动条不显示</div><div class="line">    self.scrollView.showsHorizontalScrollIndicator = NO;</div><div class="line">    self.scrollView.showsVerticalScrollIndicator = NO;</div><div class="line">    // 设置分页</div><div class="line">    self.scrollView.pagingEnabled = YES;</div><div class="line">    // 设置pagecontrol</div><div class="line">    self.pageControl.numberOfPages = count;</div><div class="line"></div><div class="line">    // 设置代理</div><div class="line">    self.scrollView.delegate = self;</div><div class="line"></div><div class="line">    [self addTimer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)addTimer</div><div class="line">&#123;</div><div class="line">    NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(nextImage) userInfo:nil repeats:YES];</div><div class="line">    self.timer = timer;</div><div class="line">    // 消息循环</div><div class="line">    NSRunLoop *runLoop = [NSRunLoop currentRunLoop];</div><div class="line">    [runLoop addTimer:timer forMode:NSRunLoopCommonModes];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)nextImage</div><div class="line">&#123;</div><div class="line">    // 当前页码</div><div class="line">    NSInteger page = self.pageControl.currentPage;</div><div class="line">    if (page == self.pageControl.numberOfPages - 1) &#123;</div><div class="line">        page = 0;</div><div class="line">    &#125; else &#123;</div><div class="line">        page++;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    CGFloat offsetX = page * self.scrollView.frame.size.width;</div><div class="line">    [UIView animateWithDuration:1.0 animations:^&#123;</div><div class="line">        self.scrollView.contentOffset = CGPointMake(offsetX, 0);</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">#pragma mark - scrollView代理方法</div><div class="line">// 正在滚动时</div><div class="line">- (void)scrollViewDidScroll:(UIScrollView *)scrollView</div><div class="line">&#123;</div><div class="line">    int page = (scrollView.contentOffset.x + scrollView.frame.size.width / 2) / scrollView.frame.size.width;</div><div class="line">    self.pageControl.currentPage = page;</div><div class="line">&#125;</div><div class="line">// 开始拖拽的时候调用</div><div class="line">- (void)scrollViewWillBeginDragging:(UIScrollView *)scrollView</div><div class="line">&#123;</div><div class="line">    // 停止定时器</div><div class="line">    [self.timer invalidate];</div><div class="line">&#125;</div><div class="line">// 结束拖拽的时候调用</div><div class="line">- (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate</div><div class="line">&#123;</div><div class="line">    [self addTimer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先我们要先建一个project，选择iOS下的第一个Application 中的Single View Application&lt;/p&gt;
&lt;p&gt;开始工作已经准备完毕现在我们进入到Main.storyboard拖控件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要用到的控件有&lt;/stro
    
    </summary>
    
    
      <category term="UI" scheme="http://MelodyZhy.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>Swift-面向对象</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Swift-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Swift-面向对象/</id>
    <published>2017-08-01T07:29:51.000Z</published>
    <updated>2017-08-01T07:30:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/071508461748886.png" alt=""></p>
<p><img src="/images/071509105654169.png" alt=""></p>
<p><img src="/images/071509525023723.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/071508461748886.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/071509105654169.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/07150952502
    
    </summary>
    
    
      <category term="Swift" scheme="http://MelodyZhy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-函数闭包Closure</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Swift-%E5%87%BD%E6%95%B0%E9%97%AD%E5%8C%85Closure/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Swift-函数闭包Closure/</id>
    <published>2017-08-01T07:28:19.000Z</published>
    <updated>2017-08-01T07:29:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>闭包原型应该是OC中的block</p>
<p>还记得block的写法嘛</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int (^myBlock)(int, int) = ^(int a, int b) &#123;</div><div class="line">     <span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><img src="/images/071502546907634.png" alt=""></p>
<p><img src="/images/071503150344918.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;闭包原型应该是OC中的block&lt;/p&gt;
&lt;p&gt;还记得block的写法嘛&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div
    
    </summary>
    
    
      <category term="Swift" scheme="http://MelodyZhy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-结构体</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Swift-%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Swift-结构体/</id>
    <published>2017-08-01T07:26:55.000Z</published>
    <updated>2017-08-01T07:27:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Swift语言中的结构体和C++很像它可以在内部带函数，下面来展示一下</p>
<p><img src="/images/071448135494361.png" alt=""></p>
<p><img src="/images/071449245184380.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift语言中的结构体和C++很像它可以在内部带函数，下面来展示一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/071448135494361.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/071449245184380.png&quot; a
    
    </summary>
    
    
      <category term="Swift" scheme="http://MelodyZhy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-函数</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Swift-%E5%87%BD%E6%95%B0/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Swift-函数/</id>
    <published>2017-08-01T07:24:52.000Z</published>
    <updated>2017-08-01T07:26:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>这一篇说一下Swift中函数的写法以及用法</p>
<p><img src="/images/071418117996072.png" alt=""></p>
<p><img src="/images/071427376596665.png" alt=""></p>
<p><img src="/images/071429384402834.png" alt=""></p>
<p><img src="/images/071433582689354.png" alt=""></p>
<p><img src="/images/071438408468458.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一篇说一下Swift中函数的写法以及用法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/071418117996072.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/071427376596665.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;
    
    </summary>
    
    
      <category term="Swift" scheme="http://MelodyZhy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift-控制语句</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Swift-%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Swift-控制语句/</id>
    <published>2017-08-01T07:15:52.000Z</published>
    <updated>2017-08-01T07:17:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天写些前几天学习的swift语言基础知识，几天前想写来着，但插入代码这工具没有Swift，就放下了(吐槽下 “硕大的”博客园竟然不支持Swift 是不是OUT了)</p>
<p>那么笔者只能用我在Xcode上的截图显示了</p>
<p>看完我这几篇关于Swift的博客，要是之前有编程基础的应该就会对Swift的有所了解了</p>
<p>下面进入正题，这一篇主要体现一下Swift这门语言的变量、常量、变量的命名、以及控制语句</p>
<p><strong>变量和常量</strong></p>
<p><img src="/images/071345251129705.png" alt=""></p>
<p><strong>Swift语言的控制语句</strong></p>
<p><img src="/images/071355214874276.png" alt=""></p>
<p><img src="/images/071359202682129.png" alt=""></p>
<p><img src="/images/071400595491297.png" alt=""></p>
<p><img src="/images/071404586596647.png" alt=""></p>
<p><img src="/images/071405366598104.png" alt=""></p>
<p><img src="/images/071406188627344.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天写些前几天学习的swift语言基础知识，几天前想写来着，但插入代码这工具没有Swift，就放下了(吐槽下 “硕大的”博客园竟然不支持Swift 是不是OUT了)&lt;/p&gt;
&lt;p&gt;那么笔者只能用我在Xcode上的截图显示了&lt;/p&gt;
&lt;p&gt;看完我这几篇关于Swift的博客，要
    
    </summary>
    
    
      <category term="Swift" scheme="http://MelodyZhy.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>NSArray排序的一些方法</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/NSArray%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/NSArray排序的一些方法/</id>
    <published>2017-08-01T07:11:53.000Z</published>
    <updated>2017-08-01T08:07:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>进来看见的是代码，这里用来控制颜值</p>
<p>进来看见的是代码，这里用来控制颜值</p>
<p>NSArray排序的一些方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line">/* 大体上，OC中常用的数组排序有以下几种方法：    </div><div class="line">               sortedArrayUsingSelector:</div><div class="line">               sortedArrayUsingComparator:</div><div class="line">               sortedArrayUsingDescriptors:</div><div class="line">*/</div><div class="line">/*</div><div class="line">1、简单排序（sortedArrayUsingSelector:）</div><div class="line">如果只是对字符串的排序，可以利用sortedArrayUsingSelector:方法就可以了，代码如下</div><div class="line">*/</div><div class="line">// 简单排序</div><div class="line">void sortArray1()&#123;</div><div class="line">    NSArray *array = [NSArray arrayWithObjects:@&quot;abc&quot;,@&quot;456&quot;,@&quot;123&quot;,@&quot;789&quot;,@&quot;ef&quot;, nil];</div><div class="line">    NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(compare:)];</div><div class="line">    NSLog(@&quot;排序后:%@&quot;,sortedArray);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">当然，除了利用字符串自带的compare:方法，也可以自己写compare:方法，进行对象的比较；如下：</div><div class="line"></div><div class="line">首先是新建了Person类，实现方法如下（头文件就省了）：</div><div class="line">*/</div><div class="line">#import &quot;Person.h&quot;</div><div class="line">@implementation Person</div><div class="line"></div><div class="line">// 直接实现静态方法，获取带有name和age的Person对象</div><div class="line">+(Person *)personWithAge:(int) age withName:(NSString *)name&#123;</div><div class="line">    Person *person = [[Person alloc] init];</div><div class="line">    person.age = age;</div><div class="line">    person.name = name;</div><div class="line">    return person;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 自定义排序方法</div><div class="line">-(NSComparisonResult)comparePerson:(Person *)person&#123;</div><div class="line">  // 默认按年龄排序</div><div class="line">    NSComparisonResult result = [[NSNumber numberWithInt:person.age] compare:[NSNumber numberWithInt:self.age]];// 注意:基本数据类型要进行数据转换  </div><div class="line">  // 如果年龄一样，就按照名字排序</div><div class="line">    if (result == NSOrderedSame) &#123;</div><div class="line">        result = [self.name compare:person.name];</div><div class="line">    &#125;</div><div class="line">    return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">// 主函数代码如下：</div><div class="line"></div><div class="line">void sortArray2()&#123;</div><div class="line">    Person *p1 = [Person personWithAge:23 withName:@&quot;zhangsan&quot;];</div><div class="line">    Person *p2 = [Person personWithAge:21 withName:@&quot;lisi&quot;];</div><div class="line">    Person *p3 = [Person personWithAge:24 withName:@&quot;wangwu&quot;];</div><div class="line">    Person *p4 = [Person personWithAge:24 withName:@&quot;liwu&quot;];</div><div class="line">    Person *p5 = [Person personWithAge:20 withName:@&quot;liwu&quot;];</div><div class="line">    NSArray *array = [NSArray arrayWithObjects:p1,p2,p3,p4,p5, nil];</div><div class="line">    NSArray *sortedArray = [array sortedArrayUsingSelector:@selector(comparePerson:)];</div><div class="line">    NSLog(@&quot;排序后:%@&quot;,sortedArray);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">2、利用block语法（sortedArrayUsingComparator:）</div><div class="line">苹果官方提供了block语法，比较方便。其中数组排序可以用sortedArrayUsingComparator:方法，代码如下：</div><div class="line">*/</div><div class="line">void sortArray3()&#123;</div><div class="line">    NSArray *array = [NSArray arrayWithObjects:@&quot;1bc&quot;,@&quot;4b6&quot;,@&quot;123&quot;,@&quot;789&quot;,@&quot;3ef&quot;, nil];</div><div class="line">    NSArray *sortedArray = [array sortedArrayUsingComparator:^NSComparisonResult(id obj1, id obj2) &#123;</div><div class="line"></div><div class="line">   // 这里的代码可以参照上面compare:默认的排序方法，也可以把自定义的方法写在这里，给对象排序</div><div class="line">        NSComparisonResult result = [obj1 compare:obj2];</div><div class="line">        return result;</div><div class="line">    &#125;];</div><div class="line">    NSLog(@&quot;排序后:%@&quot;,sortedArray);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">3、高级排序（sortedArrayUsingDescriptors:）</div><div class="line">如果是这样一种情况呢？Person类里有另外一个类的变量，比如说Person类除了name，age变量，还有一辆车Car类型，Car类里有个name属性。对Person对象进行排序，有这样的要求：按照Car的name排序，如果是同一辆车，也就是Car的name相同，那么再按照年龄进行排序，如果年龄也相同，最后按照Person的name进行排序。</div><div class="line"></div><div class="line">上面这样就要使用第三种方法，利用排序描述器，不多说，有兴趣可以看看API介绍。代码如下：</div><div class="line"></div><div class="line">首先写个Car类，实现类Car.m代码如下：</div><div class="line">*/</div><div class="line">#import &quot;Car.h&quot;</div><div class="line">@implementation Car</div><div class="line"></div><div class="line">+(Car *)initWithName:(NSString *)name&#123;</div><div class="line">    Car *car = [Car alloc] init];</div><div class="line">    car.name = name;</div><div class="line">    return car;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">// 然后改写Person类，实现类Person.m代码如下:</div><div class="line"></div><div class="line">#import &quot;Person.h&quot;</div><div class="line">#import &quot;Car.h&quot;</div><div class="line">@implementation Person</div><div class="line"></div><div class="line">+(Person *)personWithAge:(int)age withName:(NSString *)name withCar:(Car *)car&#123;</div><div class="line">    Person *person = [[Person alloc] init];</div><div class="line">    person.age = age;</div><div class="line">    person.name = name;</div><div class="line">    person.car = car;</div><div class="line">    return person;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 这里重写description方法，用于最后测试排序结果显示</div><div class="line">-(NSString *)description&#123;</div><div class="line">    return [NSString stringWithFormat:@&quot;age is %zi , name is %@, car is %@&quot;,_age,_name,_car.name];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div><div class="line">// 主函数代码如下：</div><div class="line"></div><div class="line">void sortArray4()&#123;</div><div class="line">        // 首先来3辆车，分别是奥迪、劳斯莱斯、宝马</div><div class="line">        Car *car1 = [Car initWithName:@&quot;Audio&quot;];</div><div class="line">        Car *car2 = [Car initWithName:@&quot;Rolls-Royce&quot;];</div><div class="line">        Car *car3 = [Car initWithName:@&quot;BMW&quot;];</div><div class="line">        </div><div class="line">        // 再来5个Person，每人送辆车，分别为car2、car1、car1、car3、car2</div><div class="line">        Person *p1 = [Person personWithAge:23 withName:@&quot;zhangsan&quot; withCar:car2];</div><div class="line">        Person *p2 = [Person personWithAge:21 withName:@&quot;zhangsan&quot; withCar:car1];</div><div class="line">        Person *p3 = [Person personWithAge:24 withName:@&quot;lisi&quot; withCar:car1];</div><div class="line">        Person *p4 = [Person personWithAge:23 withName:@&quot;wangwu&quot; withCar:car3];</div><div class="line">        Person *p5 = [Person personWithAge:23 withName:@&quot;wangwu&quot; withCar:car2];</div><div class="line"></div><div class="line">    </div><div class="line">        // 加入数组</div><div class="line">        NSArray *array = [NSArray arrayWithObjects:p1,p2,p3,p4,p5, nil];</div><div class="line">        </div><div class="line">        // 构建排序描述器</div><div class="line">        NSSortDescriptor *carNameDesc = [NSSortDescriptor sortDescriptorWithKey:@&quot;car.name&quot; ascending:YES];</div><div class="line">        NSSortDescriptor *personNameDesc = [NSSortDescriptor sortDescriptorWithKey:@&quot;name&quot; ascending:YES];</div><div class="line">        NSSortDescriptor *personAgeDesc = [NSSortDescriptor sortDescriptorWithKey:@&quot;age&quot; ascending:YES];</div><div class="line">        </div><div class="line">        // 把排序描述器放进数组里，放入的顺序就是你想要排序的顺序</div><div class="line">        // 我这里是：首先按照年龄排序，然后是车的名字，最后是按照人的名字</div><div class="line">        NSArray *descriptorArray = [NSArray arrayWithObjects:personAgeDesc,carNameDesc,personNameDesc, nil];</div><div class="line">        </div><div class="line">        NSArray *sortedArray = [array sortedArrayUsingDescriptors: descriptorArray];</div><div class="line">        NSLog(@&quot;%@&quot;,sortedArray);</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">从结果看出，先按照age排序，如果age相同，按照car排序，如果car相同，按照name排序。</div><div class="line"></div><div class="line">（注意：上面两种排序方法要想实现字符串显示，请重写description方法）</div><div class="line">*/</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进来看见的是代码，这里用来控制颜值&lt;/p&gt;
&lt;p&gt;进来看见的是代码，这里用来控制颜值&lt;/p&gt;
&lt;p&gt;NSArray排序的一些方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;
    
    </summary>
    
    
      <category term="Foundation框架" scheme="http://MelodyZhy.github.io/tags/Foundation%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Foundation框架中一些类的使用</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Foundation%E6%A1%86%E6%9E%B6%E4%B8%AD%E4%B8%80%E4%BA%9B%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Foundation框架中一些类的使用/</id>
    <published>2017-08-01T07:03:55.000Z</published>
    <updated>2017-08-01T07:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>提示:  这篇博文主要介绍了Foundation框架中一些类的使用方法，都是以代码方式展示的，可能会比较乱，但都是些常用的方法，这些方法常用自然就会记住所以不用纠结，注意主要记方法的第一个单词，单词不认识的话可以记前三个字母，再配合提示查找</strong></p>
<p>-—————————————————————————————————————– </p>
<p><strong>NSURL简介</strong></p>
<p>什么是URL?</p>
<p>URL的全称是Uniform Resource Locator(统一资源定位符) URL是互联网上标准资源的地址 互联网上的每个资源都有一个唯一的URL,它包含的信息指出资源的位置 根据一个URL就能找到唯一的一个资源</p>
<p>URL的格式?</p>
<p>基本URL包含协议、主机域名(服务器名称\IP地址)、路径</p>
<p>可以简单认为: URL == 协议头://主机域名/路径</p>
<p>例如：<a href="http://www.baidu.com/123.jpg" target="_blank" rel="external">http://www.baidu.com/123.jpg</a></p>
<p>常见的URL协议头(URL类型)</p>
<p>http\https :超文本传输协议资源, 网络资源</p>
<p>在URL前加<a href="https://前缀表明是用SSL加密的。" target="_blank" rel="external">https://前缀表明是用SSL加密的。</a> 你的电脑与服务器之间收发的信息传输将更 加安全。</p>
<p>Web服务器启用SSL需要获得一个服务器证书并将该证书与要使用SSL的服务器绑定。 http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443。http 的连接很简单,是无状态的</p>
<p>https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全</p>
<p>ftp :文件传输协议 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">// NSURL OC提供了一个URL处理的一个类</div><div class="line">// http</div><div class="line">// https 加密</div><div class="line">// ftp://</div><div class="line">// file:// 本地文件</div><div class="line">// NSURL 写入文件</div><div class="line">// 1)通过 URLWithString 构建一个NSURL</div><div class="line">// URLWithString  可以构建本地路径的URL</div><div class="line">// 可以构建路径,调用手机系统的程序</div><div class="line">// 打电话</div><div class="line">NSURL *url = [NSURL URLWithString:@&quot;tel://10086&quot;];</div><div class="line">// 发短信</div><div class="line">NSURL *url = [NSURL URLWithString:@&quot;sms://10086&quot;];</div><div class="line">// 保存文件到本地</div><div class="line">NSURL *url = [NSURL URLWithString:@&quot;file://地址&quot;];</div><div class="line">// 将字符串写入本地</div><div class="line">NSString *str = @&quot;xxxxx&quot;;</div><div class="line">BOOL isOk = [str writeToURL:&lt;#(NSURL *)#&gt; atomically:&lt;#(BOOL)#&gt; encoding:&lt;#(NSStringEncoding)#&gt; error:&lt;#(NSError *__autoreleasing *)#&gt;];</div><div class="line">// 第一个参数文件路径 第二个参数是否利用原子性 第三个编码标准NSUTF8StringEncoding 最后一个错误信息</div><div class="line">// 一般写入文件都要进行判断是否写入成功</div><div class="line">NSError *error;</div><div class="line">if (isOk) &#123;</div><div class="line">    NSLog(@&quot;写入成功&quot;);</div><div class="line">&#125; else &#123;</div><div class="line">    NSLog(@&quot;%@&quot;,&amp;error);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>NSString</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div></pre></td><td class="code"><pre><div class="line">// 快速创建字符串</div><div class="line">NSString *str = @&quot;xxxx&quot;;</div><div class="line">// 字符串写入文本</div><div class="line">BOOL isOk = [str writeToFile:@&quot;/User/Apple/Desktop/1.tex&quot; atomically:YES encoding:NSUTF8StringEncoding error:nil];</div><div class="line"></div><div class="line"></div><div class="line">NSString *str1 = @&quot;abc&quot;;   // a 97</div><div class="line">NSString *str2 = @&quot;abc&quot;;   // A 65</div><div class="line"></div><div class="line">//取出每个字符的ASCII码值 ,比较ASCII码值大小</div><div class="line">//compare方法比较大小</div><div class="line">//compare 默认的区分大小写的</div><div class="line">//compare 这个函数,不能增加条件</div><div class="line">//        NSComparisonResult result = [str1 compare:str2];</div><div class="line"></div><div class="line">//比较的时候,不区分大小写,参考字符的个数</div><div class="line">NSComparisonResult result = [str1 compare:str2 options:NSCaseInsensitiveSearch|NSNumericSearch];</div><div class="line">//</div><div class="line">switch (result) &#123;</div><div class="line">case NSOrderedAscending:</div><div class="line">    NSLog(@&quot;str1 &lt; str2 升序&quot;);</div><div class="line">    break;</div><div class="line">    </div><div class="line">case NSOrderedDescending:</div><div class="line">    NSLog(@&quot;str1 &gt; str2 降序&quot;);</div><div class="line">    break;</div><div class="line">    </div><div class="line">case NSOrderedSame:</div><div class="line">    NSLog(@&quot;str1 == str2 &quot;);</div><div class="line">    break;</div><div class="line">    </div><div class="line">default:</div><div class="line">    break;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//地址的比较</div><div class="line">// &quot;==&quot; 不能够判断字符串是否相等的</div><div class="line"></div><div class="line">//判断字符串内容真正是否相等,使用是</div><div class="line">//isEqualToString:</div><div class="line">//注意:他是区分大小写的</div><div class="line"></div><div class="line">if ([str1 isEqualToString:str3]) &#123;</div><div class="line">    NSLog(@&quot;相等&quot;);</div><div class="line">&#125;else&#123;</div><div class="line"></div><div class="line"> NSLog(@&quot;不相等&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">检测字符串的前缀和后缀</div><div class="line">*/</div><div class="line"></div><div class="line">NSString *url = @&quot;https://www.baidu.com&quot;;</div><div class="line"></div><div class="line">//如何检测这个字符串是否是一个网址</div><div class="line">//http://    https://</div><div class="line">// 检测一个字符串的前缀是否以 http://  开头  或者 https:// 开头</div><div class="line">// [str hasPrefix:@&quot;要检测的内容&quot;];</div><div class="line"></div><div class="line">if([url hasPrefix:@&quot;http://&quot;]||[url hasPrefix:@&quot;https://&quot;])&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;是一个网址&quot;);</div><div class="line">&#125;else&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;这不是一个网址&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//检测字符串的后缀</div><div class="line">// xxxx.jpg    判断 字符串的后缀是否是&quot;.jpg&quot;</div><div class="line">// xxxx.png</div><div class="line">// xxxx.jpeg</div><div class="line">// xxxx.gif</div><div class="line">NSString *imgName = @&quot;xxxxx.doc&quot;;</div><div class="line">// [str hasSuffix:@&quot;带检测的后缀&quot;]</div><div class="line">if([imgName hasSuffix:@&quot;.jpg&quot;]||[imgName hasSuffix:@&quot;.png&quot;]||[imgName hasSuffix:@&quot;.jpeg&quot;]||[imgName hasSuffix:@&quot;.gif&quot;])&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;是一个图片&quot;);</div><div class="line">&#125;else&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;这不是一个图片&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//字符串的查找</div><div class="line">// 查找某个字符串在另外一个字符串中首次出现的位置</div><div class="line">//     0123456789</div><div class="line">//1  @&quot;asdaiosffsdafiosasdfsffitcastasdfasd&quot;</div><div class="line">//2  @&quot;ios&quot;</div><div class="line">//   4   3</div><div class="line"></div><div class="line">//  1 rangOfString 2</div><div class="line">NSString *str1 =@&quot;asdaiosffsdafiosasdfsffitcastasdfasd&quot;;</div><div class="line">NSString *str2 =@&quot;cjk&quot;;</div><div class="line">// 字符串查找</div><div class="line">// 查找2 在 1中首次出现的位置</div><div class="line">// 如果查找到了,返回2在1中的位置和长度</div><div class="line">// 如果查找不到,返回的信息:</div><div class="line">//            location   特别大的数(NSNotFound) 最大的long类型的数</div><div class="line">//            length     0</div><div class="line">// range 结构体变量  NSRange 结构别名</div><div class="line">NSRange range =  [str1 rangeOfString:str2];</div><div class="line"></div><div class="line">//判断是否查找到了</div><div class="line">if(range.location!=NSNotFound)&#123;</div><div class="line">//range.location 表示字符串首次出现的位置</div><div class="line">//range.length 字符串出现的长度(实质上就是子字符串的长度)</div><div class="line">NSLog(@&quot;%lu,%lu&quot;,range.location,range.length);</div><div class="line">&#125;else&#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;在%@中没有找到这个字符串%@&quot;,str1,str2);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">// 字符串的截取</div><div class="line">NSString *str = @&quot;http://www.baidu.com&quot;;</div><div class="line"></div><div class="line">//1) 从xx位置开始,到最后结束(包含xx这个位置的字符)</div><div class="line">NSString *str1 = [str substringFromIndex:5];</div><div class="line">NSLog(@&quot;str1 = %@&quot;,str1);</div><div class="line"></div><div class="line"></div><div class="line">//2) 从开始位置,到xx位置结束(不包含xx这个位置)</div><div class="line">NSString *str2 = [str substringToIndex:5];</div><div class="line">NSLog(@&quot;str2 = %@&quot;,str2);</div><div class="line"></div><div class="line"></div><div class="line">//3) 截取一个范围 range</div><div class="line">NSRange r1 = &#123;3,4&#125;;</div><div class="line">NSString *str3 = [str substringWithRange:r1];</div><div class="line">NSLog(@&quot;str3 = %@&quot;,str3);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//字符串的替换</div><div class="line">// @&quot;asdfsdafasdfdasdfsa&quot;  ----&gt; a 替换成 &quot;*&quot;</div><div class="line">// @&quot; asdfasfd asdfsadf asdf asdfas asdf asdf asdfa&quot;</div><div class="line"></div><div class="line">NSString *str =@&quot;asdfsdafasdfdasdfsa&quot;;</div><div class="line"></div><div class="line">//        str stringByReplacingOccurrencesOfString:@&quot;源字符串中的内容&quot; withString:@&quot;要替换成新的内容&quot;</div><div class="line">//把a替换成 *</div><div class="line">NSString *newStr = [str stringByReplacingOccurrencesOfString:@&quot;a&quot; withString:@&quot;*&quot;];</div><div class="line">NSLog(@&quot;newStr = %@&quot;,newStr);</div><div class="line"></div><div class="line">// 把空格给去掉</div><div class="line">str =@&quot; asdfasfd asdfsadf asdf asdfas asdf asdf asdfa&quot;;</div><div class="line">newStr = [str stringByReplacingOccurrencesOfString:@&quot; &quot; withString:@&quot;&quot;];</div><div class="line"> NSLog(@&quot;newStr = %@&quot;,newStr);</div><div class="line"></div><div class="line">// 字符串转各种数值</div><div class="line">NSString *str = @&quot;11&quot;;</div><div class="line">int a = [str intValue];</div><div class="line">NSString *str1 = @&quot;12.21&quot;;</div><div class="line">double b = [str1 doubleValue];</div><div class="line">NSString *str2 = @&quot;12.12f&quot;;</div><div class="line">float c = [str2 floatValue];</div><div class="line"></div><div class="line">//OC的字符串和 C的字符串互相转换问题</div><div class="line">// char*  NSString</div><div class="line">//1) C----&gt;OC对象</div><div class="line"></div><div class="line">char *s = &quot;zhangsanfeng&quot;;</div><div class="line">printf(&quot;%s\n&quot;,s);</div><div class="line"></div><div class="line">//思路:创建一个OC的字符串对象,用C语言的字符串创建</div><div class="line">NSString *str = [NSString stringWithUTF8String:s];</div><div class="line">NSLog(@&quot;str = %@&quot;,str);</div><div class="line"></div><div class="line">//2) OC对象 --&gt; C的字符串</div><div class="line">NSString *str2 = @&quot;zbz&quot;;</div><div class="line">// 把str2 转 C的字符串</div><div class="line">const char *s1 = [str2 UTF8String];</div><div class="line">printf(&quot;s1 = %s\n&quot;,s1);</div></pre></td></tr></table></figure>
<p><strong>NSRange</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// NSRange的定义</div><div class="line">typedef struct _NSRange &#123;</div><div class="line">    NSUInteger location; // 位置</div><div class="line">    NSUInteger length;   // 从该位置算起的长度</div><div class="line">&#125; NSRange;</div></pre></td></tr></table></figure>
<p><strong>NSMutableString</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//  可变的字符串</div><div class="line">NSMutableString *str2 = [NSMutableString stringWithFormat:@&quot;Jack&quot;];</div><div class="line">// 在Jack后面加上&amp;Rose</div><div class="line">[str2 appendString:@&quot;&amp;Rose&quot;];</div><div class="line"></div><div class="line"></div><div class="line">NSMutableString *str = [NSMutableString string];</div><div class="line"></div><div class="line">//1) appendFormat 格式化的添加字符串</div><div class="line">[str appendFormat:@&quot;http://www.baidu.com/%d&quot;,100];</div><div class="line"></div><div class="line">//str http://www.baidu.com/100</div><div class="line">NSLog(@&quot;%@&quot;,str);</div><div class="line"></div><div class="line">//2) 删除字符串一部分内容</div><div class="line">[str deleteCharactersInRange:NSMakeRange(3, 4)];</div><div class="line">NSLog(@&quot;%@&quot;,str);</div><div class="line">//3) 插入一个字符串</div><div class="line">[str insertString:@&quot;p://&quot; atIndex:3];</div><div class="line">NSLog(@&quot;%@&quot;,str);</div><div class="line"></div><div class="line">//4) 替换字符串的一部分内容</div><div class="line">[str replaceCharactersInRange:NSMakeRange(11, 5) withString:@&quot;xxxxx&quot;];</div><div class="line">NSLog(@&quot;%@&quot;,str);</div><div class="line"></div><div class="line">//  注意不能这么写</div><div class="line">NSMutableString *str = @&quot;abc&quot;;</div></pre></td></tr></table></figure>
<p><strong>NSArray</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div></pre></td><td class="code"><pre><div class="line">//NSArray特点:</div><div class="line">// 一旦创建成功,内容不可改变</div><div class="line">// 只能存放OC对象</div><div class="line"></div><div class="line">// 1)创建一个空数组</div><div class="line">NSArray *arr1 = [NSArray array];</div><div class="line"></div><div class="line">// 2)创建数组,只有一个元素</div><div class="line">NSArray *arr2 = [NSArray arrayWithObject:@&quot;1&quot;];</div><div class="line"></div><div class="line">// 3)创建数组,有多个元素</div><div class="line">// nil 表示数组赋值结束</div><div class="line">// 常见写法</div><div class="line">NSArray *arr3 = [NSArray arrayWithObjects:@&quot;one&quot;,@&quot;two&quot;,@1, nil];</div><div class="line">                NSLog(@&quot;arr3 = %@&quot;,arr3);</div><div class="line">// 4)调用对象方法,创建数组</div><div class="line">// nil Nil NULL  NSNULL</div><div class="line">NSArray *arr4 = [[NSArray alloc] initWithObjects:@&quot;three&quot;,[NSNull null],@&quot;four&quot;, nil];</div><div class="line">                NSLog(@&quot;arr4 = %@&quot;,arr4);</div><div class="line">// 5)用一个数组可以创建另外一个数组</div><div class="line">NSArray *arr5 = [NSArray arrayWithArray:arr3];</div><div class="line">                NSLog(@&quot;arr5 = %@&quot;,arr5);</div><div class="line"></div><div class="line"></div><div class="line">// 用简化的方式,来定义和访问数组元素</div><div class="line">//1)用简化的方式,定义数组</div><div class="line">//格式: @[ 数组元素 ]</div><div class="line">NSArray *arr = @[@&quot;1&quot;,@&quot;one&quot;,@&quot;3&quot;,@4,@&quot;ONE&quot;];</div><div class="line"></div><div class="line">// 数组的常见的方法</div><div class="line">NSArray *arr3 = [NSArray arrayWithObjects:@&quot;one&quot;,@&quot;two&quot;,@1,@&quot;three&quot;, nil];</div><div class="line">NSLog(@&quot;arr3 = %@&quot;,arr3);</div><div class="line"></div><div class="line">// 1)获取数组的长度  count获取数组的元素的个数</div><div class="line">NSLog(@&quot;%ld&quot;,arr3.count);</div><div class="line"></div><div class="line">// 2)根据下标,获取下标对应的对象</div><div class="line">NSLog(@&quot;%@&quot;,[arr3 objectAtIndex:3]);</div><div class="line"></div><div class="line">// 3)返回元素的下标</div><div class="line">NSUInteger loc = [arr3 indexOfObject:@&quot;three&quot;];</div><div class="line">NSLog(@&quot;%ld&quot;,loc);</div><div class="line"></div><div class="line">// 4)数组中是否包含了某个元素</div><div class="line">if([arr3 containsObject:@&quot;four&quot;])&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;包含此元素&quot;);</div><div class="line"></div><div class="line">&#125;else&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;不包含&quot;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 定义一个数组</div><div class="line">NSArray *arr = @[@&quot;one&quot;,@&quot;two&quot;,@&quot;three&quot;,@&quot;four&quot;];</div><div class="line"></div><div class="line">// 对数组进行遍历</div><div class="line"></div><div class="line">//1) 普通的方式,通过下标访问</div><div class="line">for (int i=0; i&lt;arr.count; i++) &#123;</div><div class="line">    NSLog(@&quot;-&gt; %@&quot;,arr[i]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//2) 快速枚举法 for循环的增强形式</div><div class="line">for (NSString * str in arr) &#123;</div><div class="line">     NSLog(@&quot;---&gt; %@&quot;,str);</div><div class="line">&#125;</div><div class="line"></div><div class="line">//3) 使用block的方式,进行访问</div><div class="line">//                               数组元素            元素下标     是否停止</div><div class="line">//stop:YES  会停止, stop:NO 不会停止</div><div class="line">[arr enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123;</div><div class="line">    </div><div class="line">    if(idx == 2)&#123;</div><div class="line">    </div><div class="line">        *stop = YES;  //停止  // break;</div><div class="line">        </div><div class="line">    &#125;else&#123;</div><div class="line">    </div><div class="line">       NSLog(@&quot;idx = %ld,obj = %@&quot;,idx,obj);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;];</div><div class="line"></div><div class="line"></div><div class="line">// 定义一个数组</div><div class="line">NSArray *arr = @[@1,@2,@3,@4];</div><div class="line"></div><div class="line">// 1)把数组中的元素用 &quot;-&quot; 连接起来</div><div class="line">//  [数组 componentsJoinedByString @&quot;分隔符&quot;];</div><div class="line">// 1-2-3-4</div><div class="line">NSString *str = [arr componentsJoinedByString:@&quot;-&quot;];</div><div class="line">NSLog(@&quot;str = %@&quot;,str);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//2) 给一个字符串,分割成一个数组</div><div class="line">// 400-800-12580   //取得 400    12580    800</div><div class="line">NSString *str2 = @&quot;400-800-12580&quot;;</div><div class="line">NSArray *arr2 = [str2 componentsSeparatedByString:@&quot;-&quot;];</div><div class="line">NSLog(@&quot;%@&quot;,[arr2 firstObject]);</div><div class="line">NSLog(@&quot;%@&quot;,[arr2 lastObject]);</div><div class="line">NSLog(@&quot;%@&quot;,arr2[1]);</div><div class="line"></div><div class="line">str2 = @&quot;400-800-12580#400-888-11200&quot;;</div><div class="line">NSArray *arr3 = [str2 componentsSeparatedByString:@&quot;#&quot;];</div><div class="line">NSLog(@&quot;arr3 = %@&quot;,arr3);</div><div class="line"></div><div class="line">// 第一个电话的每一部分</div><div class="line">NSArray *arr4 =  [[arr3 firstObject] componentsSeparatedByString:@&quot;-&quot;];</div><div class="line">NSLog(@&quot;arr4 = %@&quot;,arr4);</div><div class="line"></div><div class="line">NSArray *arr5 =  [[arr3 lastObject] componentsSeparatedByString:@&quot;-&quot;];</div><div class="line">NSLog(@&quot;arr5 = %@&quot;,arr5);</div></pre></td></tr></table></figure>
<p><strong>NSMutableArray</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">// 数组的使用</div><div class="line">// 1)创建数组</div><div class="line"> // i. 空数组</div><div class="line">NSMutableArray *arr1 = [NSMutableArray array];</div><div class="line">NSLog(@&quot;%p&quot;,arr1);</div><div class="line"></div><div class="line"> // ii.创建的时候初始化一个元素</div><div class="line">NSMutableArray *arr2 = [NSMutableArray arrayWithObject:@&quot;one&quot;];</div><div class="line"></div><div class="line"> // iii.创建数组的时候,初始化多个元素</div><div class="line">NSMutableArray *arr3 = [NSMutableArray arrayWithObjects:@&quot;one&quot;,@&quot;two&quot;,@3,nil];</div><div class="line"></div><div class="line"> // IV . 创建一个数组,并且指定长度,</div><div class="line">NSMutableArray *arr4 = [NSMutableArray arrayWithCapacity:5];</div><div class="line"></div><div class="line">//2) 添加元素</div><div class="line">[arr1 addObject:@&quot;fengjie&quot;];</div><div class="line"></div><div class="line"> NSLog(@&quot;%p&quot;,arr1);</div><div class="line">//插入元素到指定的位置</div><div class="line">[arr1 insertObject:@&quot;zbz&quot; atIndex:0];</div><div class="line"></div><div class="line">//3) 删除元素</div><div class="line">// 根据对象内容删除</div><div class="line">[arr1 removeObject:@&quot;zbz&quot;];</div><div class="line">// 根据位置删除</div><div class="line">[arr1 removeObjectAtIndex:1];</div><div class="line">// 全部删除</div><div class="line">[arr1 removeAllObjects];</div><div class="line"></div><div class="line">//4) 修改元素</div><div class="line">// two --&gt; four</div><div class="line">[arr3 replaceObjectAtIndex:1 withObject:@&quot;four&quot;];</div><div class="line">// four --&gt; five</div><div class="line">// 更加简单地方法</div><div class="line">arr3[1] = @&quot;five&quot;;</div><div class="line">NSLog(@&quot;%@&quot;,arr3);</div><div class="line"></div><div class="line">// 5) 查找元素</div><div class="line">BOOL isSearch = [arr3 containsObject:@&quot;four&quot;];</div><div class="line">NSLog(@&quot;%d&quot;,isSearch);</div><div class="line"></div><div class="line">//6) 交换元素</div><div class="line">// 1   2   3   4   5</div><div class="line">// 5   2   3   4   1</div><div class="line">//temp = a[0];</div><div class="line">//a[0] = a[len-1];</div><div class="line">//a[len-1] = temp;</div><div class="line">NSMutableArray *arr5 =[NSMutableArray arrayWithObjects:@1,@2,@3,@4,@5, nil];</div><div class="line">// 可以交换数组元素</div><div class="line">[arr5 exchangeObjectAtIndex:0 withObjectAtIndex:4];</div><div class="line">NSLog(@&quot;%@&quot;,arr5);</div></pre></td></tr></table></figure>
<p><strong>NSDictionary</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">// NSDictionary 不可变的,一旦创建,内容就不能添加\删除(不能改动)</div><div class="line">// 1)创建空字典</div><div class="line">NSDictionary *dict1 = [NSDictionary dictionary];</div><div class="line">// key    value</div><div class="line">// zs ---&gt; 张三</div><div class="line"></div><div class="line">// ls ---&gt; 李四</div><div class="line">// 2) 创建只有一组键值对的字典</div><div class="line">NSDictionary *dict2 = [NSDictionary dictionaryWithObject:@&quot;zhangsan&quot; forKey:@&quot;zs&quot;];</div><div class="line"></div><div class="line">// 3)创建多组键值对的字典</div><div class="line">// value值,key值</div><div class="line">NSDictionary *dict3 = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;value1&quot;,@&quot;k1&quot;,@&quot;value2&quot;,@&quot;k2&quot;, nil];</div><div class="line"></div><div class="line">// 注意;</div><div class="line">// 字典的key值和value值,都必须是对象</div><div class="line"></div><div class="line">// 4)快速创建一个字典</div><div class="line">// @&#123;,,key值:value值,,,&#125;;</div><div class="line">// key值不能重复:</div><div class="line">// 如果重复了,也不会报错</div><div class="line">// 如果重复了,最后添加的将不能够保存到字典中</div><div class="line"></div><div class="line">NSDictionary *dict4 = @&#123;@&quot;zs&quot;:@&quot;zhaosi&quot;,@&quot;zs&quot;:@&quot;zhangsan&quot;,@&quot;ls&quot;:@&quot;lisi&quot;,@&quot;bz&quot;:@&quot;banzhang&quot;&#125;;</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;,dict4); // 以%@格式打印字典,控制台输出一个&#123;   &#125;</div><div class="line">// 5)获取字典的长度</div><div class="line">NSLog(@&quot;%lu&quot;,dict4.count);</div><div class="line">// 6)根据key值取出value值</div><div class="line">//      zs      zhaosi</div><div class="line">//                                   key</div><div class="line">NSString *str = [dict4 objectForKey:@&quot;zs&quot;];</div><div class="line">NSLog(@&quot;str = %@&quot;,str);</div><div class="line"></div><div class="line">//7) 字典的遍历问题</div><div class="line">// 第一步:获取所有的key</div><div class="line">// 第二步:根据key获取value</div><div class="line">//        for(NSString *key in dict4)&#123;</div><div class="line">//            NSLog(@&quot;key = %@,value = %@&quot;,key,[dict4 objectForKey:key]);</div><div class="line">//        &#125;</div><div class="line">//                                           key     value       stop</div><div class="line">[dict4 enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) &#123;</div><div class="line">    </div><div class="line">    NSLog(@&quot;%@ --&gt; %@&quot;,key,obj);</div><div class="line">    </div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<p><strong>NSMutableDictionary</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">// 1)可变字典的创建</div><div class="line">NSMutableDictionary *dict1 = [NSMutableDictionary dictionary]; // 创建空字典</div><div class="line">NSMutableDictionary *dict2 = [NSMutableDictionary dictionaryWithCapacity:3];</div><div class="line"></div><div class="line">// 2)给可变字典添加键值对</div><div class="line"></div><div class="line">[dict1 setValue:@&quot;zhaosi&quot; forKey:@&quot;ls&quot;];// 因为key值重复了,所以添加不上</div><div class="line">[dict1 setValue:@&quot;lisi&quot; forKey:@&quot;ls&quot;];  // ls</div><div class="line"></div><div class="line">[dict1 setValue:@&quot;liuneng&quot; forKey:@&quot;ln&quot;];</div><div class="line">NSLog(@&quot;%@&quot;,dict1);</div><div class="line"></div><div class="line">//3) 删除</div><div class="line">//        [dict1 removeObjectForKey:@&quot;ls&quot;];</div><div class="line">//        [dict1 removeAllObjects];</div><div class="line">NSLog(@&quot;%@&quot;,dict1);</div><div class="line">// 4)修改</div><div class="line">//</div><div class="line">[dict1 setObject:@&quot;zhaosi&quot; forKey:@&quot;ls&quot;];</div><div class="line">// 简写形式</div><div class="line">dict1[@&quot;ls&quot;] = @&quot;xxxxx&quot;;</div><div class="line"> NSLog(@&quot;%@&quot;,dict1);</div><div class="line">// 5)查找</div><div class="line">// 获取所有的key值</div><div class="line">NSArray *arr = [dict1 allKeys];</div><div class="line">if([arr containsObject:@&quot;ls&quot;])&#123;</div><div class="line"></div><div class="line">    NSLog(@&quot;存在ls的key&quot;);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> <strong>NSFileManager</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">//NSFileManager 用于判断</div><div class="line"></div><div class="line">NSString *filePath = @&quot;/Users/apple/Desktop/arr.plist&quot;;</div><div class="line"></div><div class="line"> NSString *filePath2 = @&quot;/&quot;;</div><div class="line"></div><div class="line">// 1) 判断文件是否存在</div><div class="line">//创建文件管理对象</div><div class="line">//调用defaultManager 创建一个文件管理的单例对象</div><div class="line">//单例对象:在程序运行期间,只有一个对象存在</div><div class="line">NSFileManager *fm = [NSFileManager defaultManager];</div><div class="line">// YES 存在   NO 不存在</div><div class="line">BOOL isYES = [fm fileExistsAtPath:filePath];</div><div class="line">NSLog(@&quot;--&gt;%d&quot;,isYES);</div><div class="line"></div><div class="line"></div><div class="line">if(isYES)&#123;</div><div class="line">    BOOL isDir;</div><div class="line"></div><div class="line">    // 2) 判断是否是一个目录</div><div class="line">    [fm fileExistsAtPath:filePath isDirectory:&amp;isDir];</div><div class="line">    </div><div class="line">    if (isDir) &#123;</div><div class="line">        NSLog(@&quot;这是一个目录&quot;);</div><div class="line">    &#125;else&#123;</div><div class="line">    </div><div class="line">        NSLog(@&quot;这不是一个目录&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">// 3) 判断文件是否可读</div><div class="line"></div><div class="line">isYES = [fm isReadableFileAtPath:filePath];</div><div class="line"></div><div class="line"></div><div class="line">// 4) 是否可写</div><div class="line">isYES = [fm isWritableFileAtPath:filePath2];</div><div class="line"></div><div class="line"></div><div class="line">// 5) 是否可删除</div><div class="line">isYES = [fm isDeletableFileAtPath:filePath2];</div><div class="line"></div><div class="line">         NSLog(@&quot;--&gt;%d&quot;,isYES);</div><div class="line"></div><div class="line">//创建文件对象</div><div class="line">NSFileManager *fm = [NSFileManager defaultManager];</div><div class="line">NSString *filePath = @&quot;/Users/apple/Desktop/arr.plist&quot;;</div><div class="line"></div><div class="line">NSString *dirPath = @&quot;/Users/apple/Desktop/a&quot;;</div><div class="line"></div><div class="line">//1)如何获取文件的信息(属性)</div><div class="line">NSDictionary *dict = [fm attributesOfItemAtPath:filePath error:nil];</div><div class="line">NSLog(@&quot;%@&quot;,dict);</div><div class="line">NSLog(@&quot;%@,%@&quot;,[dict objectForKey:@&quot;NSFileOwnerAccountName&quot;],dict[@&quot;NSFileOwnerAccountName&quot;]);</div><div class="line"></div><div class="line">//2)获取指定目录下文件及子目录</div><div class="line">//使用递归的方式 获取当前目录及子目录下的所有的文件及文件夹</div><div class="line">NSArray *subPaths = [fm subpathsAtPath:dirPath];</div><div class="line"></div><div class="line">//subpathsOfDirectoryAtPath 不是使用递归的方式获取的</div><div class="line">subPaths = [fm subpathsOfDirectoryAtPath:dirPath error:nil];</div><div class="line">NSLog(@&quot;subPaths = %@&quot;,subPaths);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">//3)获取指定目录下的文件及目录信息(不在获取后代路径)</div><div class="line">subPaths = [fm contentsOfDirectoryAtPath:dirPath error:nil];</div><div class="line">NSLog(@&quot;subPaths = %@&quot;,subPaths);</div></pre></td></tr></table></figure>
<p><strong>NSNumber</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">int a = 10;</div><div class="line">int x = 100;</div><div class="line">float f1 = 3.23f;</div><div class="line">double d1 = 2.34;</div><div class="line"></div><div class="line">// numberWithInt   把int   转换为 NSNumber</div><div class="line">NSNumber *intObj = [NSNumber numberWithInt:a];</div><div class="line">NSMutableArray *array = [NSMutableArray arrayWithObjects:intObj, nil];</div><div class="line"></div><div class="line">//  float ---&gt; NSNumber</div><div class="line">NSNumber *floatObj = [NSNumber numberWithFloat:f1];</div><div class="line">[array addObject:floatObj];</div><div class="line"></div><div class="line"></div><div class="line">// double ---&gt; NSNumber</div><div class="line">NSNumber *dObj = [NSNumber numberWithDouble:d1];</div><div class="line">//把对象添加到数组中</div><div class="line">[array addObject:dObj];</div><div class="line">//@(变量名)  ---&gt; 把 x 转换为NSNumber对象</div><div class="line">[array addObject:@(x)];</div><div class="line">//@数值,把数值包装成对象</div><div class="line">[array addObject:@18];</div><div class="line"></div><div class="line">NSLog(@&quot;array = %@&quot;,array);</div><div class="line"></div><div class="line"></div><div class="line">// 数组的第一个元素和第二个元素相加</div><div class="line"></div><div class="line">//        array[0]+array[1]</div><div class="line"></div><div class="line">//1)取出数组的元素</div><div class="line">//2)把数组元素转换为基本数据类型的数据</div><div class="line">NSNumber *n1 = array[0];</div><div class="line">int a1 = [n1 intValue];  //获取对象的整形值</div><div class="line"></div><div class="line">NSNumber *n2 = array[1];</div><div class="line">float f2 = [n2 floatValue];</div><div class="line"></div><div class="line">a1 = [array[0] intValue]+[array[1] floatValue];</div><div class="line">NSLog(@&quot;%d&quot;,a1);</div></pre></td></tr></table></figure>
<p><strong>NSValue</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">//创建一个结构体变量,保存点</div><div class="line">// p1 是 CGPoint 类型的结构体变量</div><div class="line">CGPoint p1 = CGPointMake(20, 50);</div><div class="line">NSRect r1 = NSMakeRect(0, 0, 200, 100);</div><div class="line">//创建数组</div><div class="line">NSMutableArray *arr = [NSMutableArray array];</div><div class="line">//p1 ---&gt; obj</div><div class="line">//valueWithPoint    把结构体转换为NSValue对象</div><div class="line">NSValue *pointVal = [NSValue valueWithPoint:p1];</div><div class="line">//把对象存放到数组中</div><div class="line">[arr addObject:pointVal];</div><div class="line">[arr addObject:[NSValue valueWithRect:r1]];</div><div class="line"></div><div class="line">NSLog(@&quot;arr = %@&quot;,arr);</div><div class="line"></div><div class="line">//取出r1的值</div><div class="line">// rectValue 从NSValue对象中,取得NSRect类型的值</div><div class="line">NSValue *r1Val = [arr lastObject];</div><div class="line">NSRect r2 = [r1Val rectValue];</div><div class="line"></div><div class="line">NSLog(@&quot;%@&quot;,NSStringFromRect(r2));</div><div class="line"></div><div class="line"></div><div class="line">typedef struct D&#123;</div><div class="line">int year;</div><div class="line">int month;</div><div class="line">int day;</div><div class="line"></div><div class="line">&#125; MyDate;   //MyDate是一个别名</div><div class="line"></div><div class="line">// 保存 一个 年月日</div><div class="line">// 2015-7-30</div><div class="line">MyDate md = &#123;2015,7,30&#125;;</div><div class="line">// md -----&gt; obj</div><div class="line">//@encode(MyDate) 作用,把MyDate类型生成一个常量字符串描述</div><div class="line">NSValue *val = [NSValue valueWithBytes:&amp;md objCType:@encode(MyDate)];</div><div class="line">//定义一个数组,把val存到数组中</div><div class="line">NSMutableArray *arr = [NSMutableArray arrayWithObject:val];</div><div class="line"></div><div class="line">//从数组中取出来NSValue对象</div><div class="line">//从对象中,取出结构体变量的值</div><div class="line">// 传入一个结构体变量的地址</div><div class="line">MyDate tmd;</div><div class="line">// getValue获取结构值,保存到结构体变量tmd</div><div class="line">[val getValue:&amp;tmd];</div><div class="line"></div><div class="line">NSLog(@&quot;%d,%d,%d&quot;,tmd.year,tmd.month,tmd.day);</div></pre></td></tr></table></figure>
<p><strong>NSDate</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">//创建一个日期时间对象</div><div class="line">//获取当前时间</div><div class="line">NSDate *d1 = [NSDate date];</div><div class="line">//0时区时间,北京 东8区</div><div class="line">// 当前时间上+8小时,得到的就是现在时间</div><div class="line">NSLog(@&quot;%@&quot;,d1);</div><div class="line">//2015-07-30 12:20:25 +0000</div><div class="line"></div><div class="line">//格式化日期</div><div class="line">//NSDateFormatter 日期格式化</div><div class="line">//2015年07月30日 20:20:25</div><div class="line">//2015-07-30 20:22:15</div><div class="line">NSDateFormatter *formatter = [NSDateFormatter new];</div><div class="line">//设置日期的显示格式的</div><div class="line">// yyyy 表示四位的年份</div><div class="line">// MM   表示2位的月份</div><div class="line">// dd   表示2位的天数</div><div class="line">// HH   表示24小时制得小数   hh  - 12小时值</div><div class="line">// mm   表示2位的分钟数</div><div class="line">// ss   表示2位的秒数</div><div class="line">formatter.dateFormat = @&quot;yyyy年MM月dd日 HH:mm:ss&quot;;</div><div class="line">formatter.dateFormat = @&quot;yyyy-MM-dd HH:mm:ss&quot;;</div><div class="line">//格式化日期</div><div class="line">NSString *dateStr = [formatter stringFromDate:d1];</div><div class="line">NSLog(@&quot;%@&quot;,dateStr);</div><div class="line"></div><div class="line"></div><div class="line">NSDateFormatter *formatter = [NSDateFormatter new];</div><div class="line">//设置日期的显示格式的</div><div class="line">// yyyy 表示四位的年份</div><div class="line">// MM   表示2位的月份</div><div class="line">// dd   表示2位的天数</div><div class="line">// HH   表示24小时制得小数   hh  - 12小时值</div><div class="line">// mm   表示2位的分钟数</div><div class="line">// ss   表示2位的秒数</div><div class="line">formatter.dateFormat = @&quot;yyyy年MM月dd日 HH:mm:ss&quot;;</div><div class="line">formatter.dateFormat = @&quot;yyyy-MM-dd HH:mm:ss&quot;;</div><div class="line"></div><div class="line">//计算明天的此刻</div><div class="line">// 距现在时间 24 小时以后,明天的此刻</div><div class="line">NSTimeInterval t = 60*60*24;</div><div class="line">NSDate *tom = [NSDate dateWithTimeIntervalSinceNow:t];</div><div class="line">//计算昨天的时间</div><div class="line">NSDate *zuotian = [NSDate dateWithTimeIntervalSinceNow:-t];</div><div class="line">//格式化显示时间</div><div class="line">NSString *timeStr = [formatter stringFromDate:zuotian];</div><div class="line">NSLog(@&quot;timeStr = %@&quot;,timeStr);</div><div class="line"></div><div class="line">//日期对象</div><div class="line">//2015-07-30 20:22:15</div><div class="line">//year month day</div><div class="line">// NSCalendar 日期类,可以帮我们快速的获取年月日 时分秒信息</div><div class="line">NSDate *d = [NSDate date];</div><div class="line"></div><div class="line">//创建日期的对象</div><div class="line">NSCalendar *cal = [NSCalendar currentCalendar];</div><div class="line"></div><div class="line">//cal components:获取日期的哪些部分 fromDate:日期对象</div><div class="line">NSDateComponents *coms =  [cal components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay fromDate:d];</div><div class="line"></div><div class="line">NSLog(@&quot;year:%ld,month:%ld,day:%ld&quot;,coms.year,coms.month,coms.day);</div></pre></td></tr></table></figure>
<p>小知识点：</p>
<p><strong>位枚举：</strong>枚举值是2的0次方、1次方、2次方…</p>
<p>它的存在是为了有些方法中需要写入枚举值，但有时候我们并不需要枚举这时候可以用0来填写枚举值</p>
<p>他的枚举值可以用“ | ”（或）来一起选择</p>
<p>解释：<br>​      2 的 0 次方   1        00000001</p>
<p>​      2 的 1 次方   2        00000010</p>
<p>​      2 的 2 次方   4        00000100</p>
<p>​      2 的 3 次方   8        00001000</p>
<p>用“ | ”或正好能把想用的枚举值都用到 例如用1和2 00000011</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;提示:  这篇博文主要介绍了Foundation框架中一些类的使用方法，都是以代码方式展示的，可能会比较乱，但都是些常用的方法，这些方法常用自然就会记住所以不用纠结，注意主要记方法的第一个单词，单词不认识的话可以记前三个字母，再配合提示查找&lt;/strong&gt;
    
    </summary>
    
    
      <category term="Foundation框架" scheme="http://MelodyZhy.github.io/tags/Foundation%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C知识总结第五部分</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Objective-C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Objective-C知识总结第五部分/</id>
    <published>2017-08-01T06:58:00.000Z</published>
    <updated>2017-08-01T07:37:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>进来看见的是代码，这里用来控制颜值</p>
<p>进来看见的是代码，这里用来控制颜值</p>
<p><strong>block的基本使用</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">// 有参有返回值</div><div class="line">/*</div><div class="line">格式:</div><div class="line">返回值类型 (^变量名)(参数类型及个数) = ^(形参列表)&#123;</div><div class="line"></div><div class="line">     代码块语句;</div><div class="line"></div><div class="line">     return ;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">*/</div><div class="line">// 定义一个有参数\有返回值的block</div><div class="line">int (^myblock1)(int ,int) = ^(int x,int y)&#123;</div><div class="line"></div><div class="line">return x+y;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">int sum = myblock1(10,20);</div><div class="line">NSLog(@&quot;sum = %d&quot;,sum);</div><div class="line"></div><div class="line">// 给变量重新赋值</div><div class="line">myblock1 =^(int x,int y)&#123;</div><div class="line"></div><div class="line">return x*y;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">// 使用block,接收返回值</div><div class="line">sum = myblock1(10,20);</div><div class="line">NSLog(@&quot;sum = %d&quot;,sum);</div><div class="line">33  </div><div class="line">// 有参无返回值</div><div class="line"></div><div class="line">/*</div><div class="line">格式:</div><div class="line">void (^变量名)(参数类型及个数) = ^(形参列表)&#123;</div><div class="line"></div><div class="line">  代码块语句;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">*/</div><div class="line">// 定义一个变量myblock2 同时进行赋值</div><div class="line">void (^myblock2)(int ,int )=^(int a,int b)&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;a + b = %d&quot;,a+b);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">myblock2(34,12);</div><div class="line"></div><div class="line">// 先定义变量,再赋值</div><div class="line">myblock2 = ^(int x,int y)&#123;</div><div class="line"></div><div class="line">int m = x&gt;y?x:y;</div><div class="line">NSLog(@&quot;max = %d&quot;,m);</div><div class="line"></div><div class="line">&#125;;</div><div class="line">myblock2(34,12);</div><div class="line"></div><div class="line">// 无参无返回值 block</div><div class="line"></div><div class="line">/*</div><div class="line">//定义一个没有参数\没有返回值的block变量,并且赋值了</div><div class="line">void (^block变量名)() = ^()&#123;</div><div class="line"></div><div class="line">   代码块的语句;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">优化:</div><div class="line">void (^block变量名)() = ^&#123;</div><div class="line"></div><div class="line">代码块的语句;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//block变量的使用</div><div class="line">block变量名();</div><div class="line"></div><div class="line">*/</div><div class="line"></div><div class="line">void (^myBlock4)()=^&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;xxxx&quot;);</div><div class="line">printf(&quot;xxxxxx&quot;);</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">//使用block变量</div><div class="line">myBlock4();</div></pre></td></tr></table></figure>
<p><strong>block的typedef</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef int (^myBlock)(int,int);</div><div class="line"></div><div class="line">myBlock a = ^(int x, int y)&#123;</div><div class="line">   return x + y;</div><div class="line">&#125;;</div><div class="line">int c = a(1,2);</div></pre></td></tr></table></figure>
<p><strong>block访问外部变量</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        int m = 10;</div><div class="line">        </div><div class="line">        NSLog(@&quot;1:m = %d&quot;,m);   // 10</div><div class="line">        NSLog(@&quot;2:m addr = %p&quot;,&amp;m);         // 栈区</div><div class="line">        //        NSString *str = @&quot;abc&quot;;</div><div class="line">        //        NSLog(@&quot;str = %p&quot;,str);</div><div class="line">        </div><div class="line">        // 定义变量,并且赋值</div><div class="line">        // 当定义block的时候,block会把外部变量以const的方式复制一份</div><div class="line">        // 存放到block的所在的内存中</div><div class="line">        void (^myBlock)()=^&#123;</div><div class="line">            // m的值不能被修改</div><div class="line">            // m = 100;</div><div class="line">            </div><div class="line">            NSLog(@&quot;5:m addr = %p&quot;,&amp;m);     // 堆区</div><div class="line">            // 可以访问m的值</div><div class="line">            NSLog(@&quot;3:in block m = %d&quot;,m);  // 10</div><div class="line">            </div><div class="line">        &#125;;</div><div class="line">        </div><div class="line">        NSLog(@&quot;4:m addr = %p&quot;,&amp;m); // 栈区</div><div class="line">        // 使用</div><div class="line">        myBlock();</div><div class="line">           &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果为</p>
<p><img src="/images/282121321411459.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// 全局变量存在于数据段</div><div class="line">int n=0;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        __block int m = 10;</div><div class="line">        NSLog(@&quot;1:m add  = %p&quot;,&amp;m);   // 栈区地址</div><div class="line">        NSLog(@&quot;2:m = %d&quot;,m);</div><div class="line">        n = 10;</div><div class="line">        NSLog(@&quot;7:n add = %p&quot;,&amp;n); // 数据段</div><div class="line">        NSLog(@&quot;8:n = %d&quot;,n);  // 10</div><div class="line">        // 静态变量</div><div class="line">        static int a = 33;</div><div class="line">        NSLog(@&quot;----------%p&quot;, &amp;a); // 数据段</div><div class="line">   </div><div class="line">        // __block 不在以const的方式拷贝</div><div class="line">        void (^myBlock)()=^&#123;</div><div class="line">            int x = 100; // 栈区</div><div class="line">            // m的值可以被修改</div><div class="line">            m = 100;</div><div class="line">            // 全局变量可以修改</div><div class="line">            n = 100;</div><div class="line">            // 静态变量可以修改</div><div class="line">            a = 10;</div><div class="line">            NSLog(@&quot;4:m addr = %p&quot;,&amp;m);     // 堆区</div><div class="line">            // 可以访问m的值</div><div class="line">            NSLog(@&quot;3:in block m = %d&quot;,m);  // 100</div><div class="line">            </div><div class="line">            NSLog(@&quot;9:n add = %p&quot;,&amp;n); // 数据段</div><div class="line">            NSLog(@&quot;10:n = %d&quot;,n);     // 100</div><div class="line">        &#125;;</div><div class="line">        myBlock();</div><div class="line">        </div><div class="line">        NSLog(@&quot;5:m = %d&quot;,m);  // 100</div><div class="line">        NSLog(@&quot;6:m addr = %p&quot;,&amp;m); // 堆区</div><div class="line">        </div><div class="line">        NSLog(@&quot;11:n add = %p&quot;,&amp;n); // 数据段</div><div class="line">        NSLog(@&quot;12:n = %d&quot;,n);      // 100</div><div class="line">           &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>打印结果为</p>
<p><img src="/images/282139475474574.png" alt=""></p>
<p><strong>block使用注意</strong></p>
<p>静态变量 和 全局变量 在加不加 <strong>block都会直接引用变量地址。也就意味着 可以改变修改变量的值，在没有加</strong>block参数的情况下</p>
<p>全局block：定义在函数外面的block是global(全体的)的 另外如果在函数内部的block，没有捕获任何自动变量，那么它也是全局的</p>
<p>栈block：区别为是否引用了外部变量</p>
<p>堆block：是对栈block copy得来。对全局block copy 不会有任何作用，返回的仍然是全局block</p>
<p><strong>block作为函数的返回值</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 定义了一个新的类型 newType2</div><div class="line">typedef int(^myBlock)(int ,int );</div><div class="line">myBlock test()&#123;</div><div class="line">    // 返回block类型</div><div class="line">    return ^(int a,int b)&#123;</div><div class="line"></div><div class="line">        return  a+b;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">int main() &#123;</div><div class="line">    myBlock n = test();</div><div class="line">    int a = n(1,2);</div><div class="line">    NSLog(@&quot;a = %d&quot;, a); // 3</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>block助记符 inlineblock</p>
<p>block 也可以这么定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 可以加上形参</div><div class="line"></div><div class="line">int (^block)(int x,int y) = ^(int x, int y)&#123;</div><div class="line"></div><div class="line">             return x + y;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>协议 Protocol</strong></p>
<p>什么是协议?</p>
<p>一些方法的声明,一般写到一个.h的头文件中</p>
<p>方法有两种: 1) 必须实现  2) 选择实现</p>
<p>协议的作用:</p>
<p>供其他的类去遵守,如果一个类遵守了一个协议,就应该实现这个协议中定义的必须要实现的方法</p>
<p>协议的写法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@protocol xxxx &lt;NSObject&gt;</div><div class="line">// 必须实现的方法（默认）</div><div class="line">@required</div><div class="line">// 可选实现的方法</div><div class="line">@optional</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>遵守协议的步骤:  1) 导入 头文件  2) 遵守协议  3) 实现方法</p>
<p><strong>protocol类型限制</strong></p>
<p>第一种类型限制:给id类型增加限制</p>
<p>id<xxxxxxx> obj;</xxxxxxx></p>
<p>增加<xxxxxxx>以后,表示,obj只能赋值遵守了xxxxxxx协议的对象</xxxxxxx></p>
<p>id<xxxxxxx> obj = d;</xxxxxxx></p>
<p>第二种类型限制:</p>
<p>表示,obj2赋值的时候,必须是Girl对象,并其遵守 了 xxxxxxx协议.</p>
<p>Girl *mm = [Girl new];</p>
<p>Girl<xxxxxxx> *obj2 = mm;</xxxxxxx></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;进来看见的是代码，这里用来控制颜值&lt;/p&gt;
&lt;p&gt;进来看见的是代码，这里用来控制颜值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;block的基本使用&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://MelodyZhy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C知识总结第四部分</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Objective-C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Objective-C知识总结第四部分/</id>
    <published>2017-08-01T06:55:27.000Z</published>
    <updated>2017-08-01T06:57:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>ARC(automatic reference counting)机制</strong></p>
<p><strong>判断是否是ARC机制</strong></p>
<ul>
<li>ARC机制中不能使用retain release autorelease retainCount</li>
<li>在dealloc方法中不能使用 [super dealloc];</li>
</ul>
<p>在ARC下对象释放的<strong>判断依据</strong>: 对象没有强指针指向</p>
<p><strong>指针默认的都是强指针</strong>，比如我们创建的对象都是默认的强指针</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person *p1 = [[Person alloc] init];</div></pre></td></tr></table></figure>
<p>__strong 修饰符,修饰这个指针是一个强指针,也可以不写</p>
<p>__weak   修饰的这个指针是弱指针</p>
<p><strong>ARC下的循环引用问题</strong></p>
<p>当两个对象互相拥有的时候，如果定义的时候都用strong，那么就会导致循环引用的问题，双方互相强指针指向，不能被释放</p>
<p>解决这个问题的方法是：将其中一个以weak定义，就能完美解决这个问题了</p>
<p><strong>ARC下set方法内存@property参数</strong></p>
<p>ARC中的@property</p>
<p>strong：用于OC对象，相当于MRC中的retain</p>
<p>weak：用于OC对象，相当于MRC中的assign（代理一般用weak，UI控件一般用weak）</p>
<p>assign：用于基本数据类型，跟MRC中的assign一样</p>
<p>copy：一般用于NSString，跟MRC中的copy一样</p>
<p>ARC注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">__weak Person *p=[[Person alloc] init];</div><div class="line">// 不合理,对象一创建出来就被释放掉,对象释 放掉后,ARC把指针设置为nil。</div></pre></td></tr></table></figure>
<p><strong>如何让ARC的项目兼容非ARC的类</strong></p>
<p>让程序兼容ARC和非ARC部分</p>
<ul>
<li>转变为非ARC -fno-objc-arc</li>
<li>转变为ARC的, -f-objc-arc </li>
</ul>
<p>在哪里添加编译器标示 -fno-objc-arc如下图</p>
<p><img src="/images/282035523135925.png" alt=""></p>
<p><strong>将MRC转化为ARC（不建议这么使用，若要尝试做好备份）</strong></p>
<p><img src="/images/282044002199933.png" alt=""></p>
<p><strong>分类(Category)</strong></p>
<p>分类的使用<strong>注意事项</strong>:</p>
<p>———&gt;在分类的声明中不能声明实例变量</p>
<p>———&gt;不能定义实例变量 也不能使用 @property</p>
<p>———&gt;在分类的方法中,可以访问类中的实例变量</p>
<p>———&gt;在分类中存在和类同名的方法  优先访问的时 分类中 的方法</p>
<p>当在多个类别中有同名的方法的时候,这时候,执行的最后编译的那个类别的同名方法</p>
<p>分类的 &gt; 原类</p>
<p>最后编译的分类 &gt;  其他的分类</p>
<p><strong>分类（Category）非正式协议</strong></p>
<p>非正式协议就是给NSObject类或Foundation框架中的子类创建的类目(分类)，即给它们添加方法，叫做非正式协议</p>
<p><strong>类的延展的概念</strong></p>
<p>延展类别又称为扩展(Extendsion)</p>
<p>Extension是Category的一个特例 其名字为匿名(为空),并且新添加的方法一定要予以实现。(Category没有这个限制)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 这个一般用在.m文件中，作为私有的方法和成员变量</div><div class="line"></div><div class="line">@interface Student ()</div><div class="line">&#123;</div><div class="line">   // 可以添加成员变量</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 添加方法</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;ARC(automatic reference counting)机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;判断是否是ARC机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ARC机制中不能使用retain release autorelease
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://MelodyZhy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C知识总结第三部分</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Objective-C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Objective-C知识总结第三部分/</id>
    <published>2017-08-01T06:52:41.000Z</published>
    <updated>2017-08-01T06:55:04.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>手动内存管理MRC</strong></p>
<p>首先介绍一下<strong>引用计数器</strong>：用来保存当前对象有几个东西在使用它(数字)</p>
<p><strong>引用计数器的作用</strong>:用来判断对象是否应该回收内存空间(如果对象不等于nil,当引用计数器为0,此时要回收对象的内存空间)</p>
<p><strong>引用计数器的操作</strong>:</p>
<ul>
<li>retain    使得引用计数器+1</li>
<li>release   使的引用计数器-1</li>
<li>retainCount  得到引用计数器的值</li>
</ul>
<p>如果一个对象被释放的时候,会调用该对象的dealloc方法</p>
<p>注意:</p>
<ul>
<li>dealloc方法是NSObject 的,一般我们要重写dealloc方法</li>
<li>在dealloc 方法的内部,要调用 [super dealloc];</li>
</ul>
<p><strong>内存管理的范围:</strong></p>
<ul>
<li>所有的集成了NSObject的对象的内存管理</li>
<li>基本数据类型(int double float char struct enum )的数据内存不需要我们进行管理</li>
</ul>
<p><strong>内存管理的原则:</strong></p>
<ol>
<li><p>如果对象有人使用,就不应该回收  </p>
<p>如果你想使用这个对象,应该让这个对象 retain一次  </p>
<p>如果你不想使用这个对象了,应该让这个对象 relase一次</p>
</li>
<li><p>谁创建 谁release</p>
</li>
<li><p>谁 retain 谁 release</p>
</li>
</ol>
<p><strong>内存管理研究的内容:</strong></p>
<ol>
<li><p>野指针：  1)定义的指针变量没有初始化     2)指向的空间已经被释放</p>
</li>
<li><p>内存泄露:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">             Person *p  = [Person new];</div><div class="line"> </div><div class="line">             &#125;</div><div class="line">/*</div><div class="line">             p 栈区</div><div class="line">             [Person new];  堆区</div><div class="line"> </div><div class="line">             如果栈区的p已经释放了,而堆区的空间还没有释放,堆区的空间就被泄露了</div><div class="line">*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>set方法内存管理</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//  Dog* _dog;</div><div class="line"> </div><div class="line">//  对于对象作为另外一个类的实例变量</div><div class="line"> </div><div class="line">- (void)setDog:(Dog*)dog &#123;</div><div class="line"> </div><div class="line"> //  判断对象是否是原对象</div><div class="line">        if(_dog != dog) &#123;</div><div class="line"> </div><div class="line">           //2) release旧值</div><div class="line">           [_dog release];</div><div class="line"> </div><div class="line">            // retain 新的值,并且赋值给实例变量</div><div class="line">           _dog = [dog retain];</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p><strong>循环retain问题</strong></p>
<p>循环的retain 会导致两个对象都会内存泄露</p>
<p>防止方法:</p>
<ol>
<li>让某个对象多释放一次 (注意顺序)</li>
<li>一端使用 assign   一端使用retain(推荐使用)</li>
</ol>
<p><strong>NSString类的内存管理问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    @autoreleasepool &#123;</div><div class="line">        </div><div class="line">        //定义字符串</div><div class="line">        //字符串的常量池,</div><div class="line">        //如果你需要的字符串在常量池中已经存在了,不会分配内存空间</div><div class="line">        //使用字符串的时候,</div><div class="line">        // @&quot;abc&quot;  stringWithString    alloc initWithString  都在常量区/\</div><div class="line">        </div><div class="line">        //0x100001030 小</div><div class="line">        NSString *str1 = @&quot;abc&quot;;   //@&quot;abc&quot; 字符串的常量</div><div class="line">        NSString *str3 = [NSString stringWithString:@&quot;abc&quot;];   //常量区</div><div class="line">        NSString *str5 = [[NSString alloc] initWithString:@&quot;abc&quot;]; //也在常量区</div><div class="line">        NSString *str6 = [[NSString alloc] init];//常量区</div><div class="line">        str6 = @&quot;abc&quot;;</div><div class="line"></div><div class="line">        </div><div class="line">        //0x100202030 大</div><div class="line">        //如果在常量区 str2  str4 地址应该是一样的</div><div class="line">        //实际上不一样的,所以 str2 str4都在堆区</div><div class="line">        NSString *str2 = [NSString stringWithFormat:@&quot;abc&quot;];   //不是在栈区,在堆区</div><div class="line">        NSString *str4 = [[NSString alloc] initWithFormat:@&quot;abc&quot;];//不是在栈区,在堆区</div><div class="line">        </div><div class="line">        </div><div class="line">        //0x7fff5fbff764</div><div class="line">        int a = 10;  //栈区</div><div class="line">        </div><div class="line">        NSLog(@&quot;str1 = %@,%p,%lu&quot;,str1,str1,str1.retainCount);</div><div class="line">        NSLog(@&quot;str2 = %@,%p,%lu&quot;,str2,str2,str2.retainCount);</div><div class="line">        NSLog(@&quot;str3 = %@,%p,%lu&quot;,str3,str3,str3.retainCount);</div><div class="line">        NSLog(@&quot;str4 = %@,%p,%lu&quot;,str4,str4,str4.retainCount);</div><div class="line">        NSLog(@&quot;str5 = %@,%p,%lu&quot;,str5,str5,str5.retainCount);</div><div class="line">        NSLog(@&quot;str6 = %@,%p,%lu&quot;,str6,str6,str6.retainCount);</div><div class="line">        NSLog(@&quot;a = %p&quot;,&amp;a);</div><div class="line">        </div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>自动释放池 :</strong>特殊的栈结构</p>
<p>特点:  </p>
<ul>
<li>对象可以加入到自动释放池中</li>
<li>自动释放池结束的时候,会给池中的对象发送一条 release消息</li>
</ul>
<p>自动释放池的使用:</p>
<ol>
<li>创建自动释放池</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@autoreleasepool &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>​     2.  加入自动释放池</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">  在自动释放池中</div><div class="line">  [对象  autorelease];</div><div class="line">*/</div></pre></td></tr></table></figure>
<p>模拟一个Person类 类中有个一个对象方法- (void)run;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;Person.h&quot;</div><div class="line">int main(int argc, const char * argv[]) &#123;</div><div class="line">    //1 创建自动释放池</div><div class="line">    Person *p = [Person new];  // p  1</div><div class="line">    @autoreleasepool &#123;//自动释放池开始</div><div class="line">        </div><div class="line">        [p run];</div><div class="line"> </div><div class="line">        NSLog(@&quot;%lu&quot;,p.retainCount); // 1</div><div class="line">        </div><div class="line">        // [p autorelease] 把对象p加入到自动释放池中</div><div class="line">        // 注意:加入到自动释放池中以后, 引用计数不会变化</div><div class="line">        [p autorelease];  //加入自动释放池,</div><div class="line">        NSLog(@&quot;%lu&quot;,p.retainCount); // 1</div><div class="line">        </div><div class="line">        [p run];</div><div class="line">        </div><div class="line">    &#125;//自动释放池结束   [p release];</div><div class="line">    [p run];</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 我们可以给Person添加一个类方法，让其创建完对象就加入到自动释放池中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+(instancetype)person&#123;</div><div class="line">    //Person person  ---&gt; Person</div><div class="line">    //Stduent person ----&gt; Student</div><div class="line">    //创建对象</div><div class="line">    return [[[self alloc] init] autorelease];  // 返回的时对象的空间</div><div class="line">    // 能够帮我们把对象给加入到自动释放池</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;手动内存管理MRC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先介绍一下&lt;strong&gt;引用计数器&lt;/strong&gt;：用来保存当前对象有几个东西在使用它(数字)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;引用计数器的作用&lt;/strong&gt;:用来判断对象是否应该回收内存空间(如果
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://MelodyZhy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C知识总结第二部分</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Objective-C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Objective-C知识总结第二部分/</id>
    <published>2017-08-01T06:46:46.000Z</published>
    <updated>2017-08-01T06:55:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>每一个实例变量定义两个方法：设置变量的setter方法 获取变量值的getter方法</p>
<p>set方法的书写规范</p>
<ol>
<li>set方法一定是一个对象方法</li>
<li>set方法一定不能有返回值</li>
<li>set方法必须以set开头</li>
<li>set之后跟的是 实例变量去掉下划线，并且首字母大写</li>
<li>set方法一定有参数，而且参数的类型和实例变量的类型一致</li>
<li>set方法的形参名 一般是 去掉下划线的实例变量名</li>
<li>形参名不能和 实例变量名同名</li>
<li>set方法实现中，一定要用形参给实例变量赋值</li>
</ol>
<p>get方法的书写规范</p>
<ol>
<li>get方法一定是一个对象方法</li>
<li>get方法一定有返回值，返回值的类型和实例变量的类型要一致</li>
<li>get方法的方法名 是去掉下划线的实例变量名</li>
<li>get方法一定没有参数</li>
<li>get方法的实现中，一定是返回实例变量值</li>
</ol>
<p>下面演示set和get方法的代码</p>
<p>我们创建一个Person类在.h文件中的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">&#123;</div><div class="line">    NSString *_name;</div><div class="line">    int _age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 成员变量_name的setter方法和getter方法的声明</div><div class="line">- (void)setName:(NSString *)name;</div><div class="line">- (NSString *)name;</div><div class="line"></div><div class="line">// 成员变量_age的setter方法和getter方法的声明</div><div class="line">- (void)setAge:(int)age;</div><div class="line">- (int)age;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>.m文件中的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person.h&quot;</div><div class="line"></div><div class="line">@implementation Person</div><div class="line"></div><div class="line">// 成员变量_name的setter方法和getter方法的实现</div><div class="line">- (void)setName:(NSString *)name</div><div class="line">&#123;</div><div class="line">    _name = name;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">- (NSString *)name</div><div class="line">&#123;</div><div class="line">    return _name;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 成员变量_age的setter方法和getter方法的实现</div><div class="line">- (void)setAge:(int)age</div><div class="line">&#123;</div><div class="line">    //在这可以限制输入的年龄是否合法</div><div class="line">    if (age &gt;= 18) &#123;</div><div class="line">        _age = age;</div><div class="line">    &#125; else &#123;</div><div class="line">        _age = 18;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">- (int)age</div><div class="line">&#123;</div><div class="line">    return _age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>OC中没有方法的重载，所谓的参数多一个是因为方法的名称变了，提示：do: : : :</p>
<p>OC中static关键字的使用：唯一要注意的是成员变量不能定义成static，其它时候的使用跟C语言中一样，请看我之前的博客    <a href="http://www.cnblogs.com/melodyzhy/p/4667805.html" target="_blank" rel="external">&gt;—点我就能看到—&lt;</a></p>
<p>OC中的self关键字，self用到类方法中代表本类，self用到对象方法中表示这个对象</p>
<p>self修饰变量：会访问成员变量请看代码：(依然根据Person类)在.m文件中</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 成员变量_name的setter方法和getter方法的实现</div><div class="line">- (void)setName:(NSString *)name</div><div class="line">&#123;</div><div class="line">      self-&gt;speed = speed;</div><div class="line">//   self-&gt;speed等价于_name</div><div class="line">//    _name = name;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">- (NSString *)name</div><div class="line">&#123;</div><div class="line">    return _name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里再次说一下关于面对对象的四大特性分别为</p>
<p>1.抽象   2.封装    3.继承    4.多态</p>
<p>抽象性：抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。比如，我们要设计一个学生成绩管理系统，考察学生这个对象时，我们只关心他的班级、学号、成绩等，而不用去关心他的身高、体重这些信息。抽象包括两个方面，一是过程抽象，二是数据抽象。过程抽象是指任何一个明确定义功能的操作都可被使用者看作单个的实体看待，尽管这个操作实际上可能由一系列更低级的操作来完成。数据抽象定义了数据类型和施加于该类型对象上的操作，并限定了对象的值只能通过使用这些操作修改和观察。 </p>
<p>有关于封装，继承，多态请看我之前的博客(还介绍了分类)    <a href="http://www.cnblogs.com/melodyzhy/p/4626380.html" target="_blank" rel="external">&gt;—请点击这里—&lt;</a></p>
<p>成员变量修饰符的介绍</p>
<ul>
<li>@public     公开的， 在任何地方通过实例对象都可以访问</li>
<li>@private    私有的，表示只能在当前类中使用  不可以在子类中使用 但是被子类继承的</li>
<li>@protected  受保护类型，表示只能在当前类和子类中访问（默认是protected）</li>
</ul>
<p>description方法：重写父类的description方法可以改变NSLog的输出</p>
<p>如果在-description方法中使用NSLog打印self 会造成死循环</p>
<p>代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//重写父类的description</div><div class="line">-(NSString *)description&#123;</div><div class="line"></div><div class="line">  //  do something....</div><div class="line"></div><div class="line">  // 例如  return [NSString stringWithFormat:&lt;#(NSString *), ...#&gt;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类的本质是对象 </p>
<p>类对象属于Class类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 获取类对象的2种方式</div><div class="line">Class c = [Person class]; // 类方法</div><div class="line">// 或者</div><div class="line">Person *p = [Person new];</div><div class="line">Class c2 = [p class]; // 对象方法</div></pre></td></tr></table></figure>
<p>类方法中不能调用成员变量</p>
<p>SEL</p>
<p>1.方法的存储位置</p>
<ul>
<li>每个类的方法列表都存储在类对象中</li>
<li>每个方法都有一个与之对应的SEL类型的对象</li>
<li>根据一个SEL对象就可以找到方法的地址，进而调用方法</li>
<li>SEL类型的定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">typedef struct objc_selector     *SEL;</div></pre></td></tr></table></figure>
<p>2.SEL对象的创建</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SEL s = @selector(test);</div><div class="line">SEL s2 = NSSelectorFromString(@&quot;test&quot;);</div></pre></td></tr></table></figure>
<p>3.SEL对象的其他用法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 将SEL对象转为NSString对象</div><div class="line">NSString *str = NSStringFromSelector(@selector(test));</div><div class="line"></div><div class="line">Person *p = [Person new];</div><div class="line">// 调用对象p的test方法</div><div class="line">[p performSelector:@selector(test)];</div></pre></td></tr></table></figure>
<p>OC中的点语法 是Xcode的特性，Xcode帮我们做代码替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// Xcode会帮我们把下面的代码替换成[person setAge:18];</div><div class="line">person.age = 18;</div><div class="line"></div><div class="line">// Xcode会帮我们把下面的代码替换成[person age]；</div><div class="line">int a = person.age;</div></pre></td></tr></table></figure>
<p>@property 和 @synthesize</p>
<p>@property 编译器指令，编译器帮我们会进行_age _name get/set方法的声明</p>
<p>@synthesize帮我们实现了 实例变量的get和set方法</p>
<p>Xcode4.4之后@property既可以帮我进行_age _name get/set方法的声明，也可以实现实例变量的get和set方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@property (nonatomic, assign) int age;</div><div class="line">@property (nonatomic, copy) NSString *name;</div></pre></td></tr></table></figure>
<p>id是万能指针，可以指向任何对象</p>
<p>OC中的构造方法</p>
<p>重写构造方法，让对象创建成功后，就有初始的值</p>
<p>OC中给对象进行初始化的方法是：init对象方法  该方法返回的是一个对象（调用init方法的对象）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">// 当子类把父类的init覆盖了，这是默认的先执行子类的</div><div class="line">- (instancetype)init&#123;</div><div class="line"></div><div class="line">    //先让父类把父类原来做的事情做完</div><div class="line">    self = [super init];</div><div class="line">    </div><div class="line">    //判断父类是否初始化成功</div><div class="line">    if (self) &#123;</div><div class="line">        </div><div class="line">        //此处写子类初始化的内容</div><div class="line">        _age = 18;  //给年龄设置为默认值 18岁</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self; //self指代的事方法的调用者</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义构造方法</p>
<p>.h文件代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface Person : NSObject</div><div class="line">@property (nonatomic, copy) NSString* name;</div><div class="line">@property (nonatomic, assign) int age;</div><div class="line">// 自定义构造方法</div><div class="line">- (instancetype)initWithName:(NSString *)name andAge:(int)age;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>.m文件代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#import &quot;Person.h&quot;</div><div class="line"></div><div class="line">@implementation Person</div><div class="line">- (instancetype)initWithName:(NSString *)name andAge:(int)age&#123;</div><div class="line"></div><div class="line">    if (self = [super init]) &#123;</div><div class="line">        _name = name;</div><div class="line">        _age = age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每一个实例变量定义两个方法：设置变量的setter方法 获取变量值的getter方法&lt;/p&gt;
&lt;p&gt;set方法的书写规范&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;set方法一定是一个对象方法&lt;/li&gt;
&lt;li&gt;set方法一定不能有返回值&lt;/li&gt;
&lt;li&gt;set方法必须以set开头&lt;/l
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://MelodyZhy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C知识总结第一部分</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/Objective-C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/Objective-C知识总结第一部分/</id>
    <published>2017-08-01T06:35:33.000Z</published>
    <updated>2017-08-01T06:45:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>Objective-C简称OC，是一款可以开发Mac OS X平台和iOS平台应用程序的开发语言，目前最新的swift语言也可以开发以上两平台的应用。</p>
<p>OC是面对对象的语言(OC面对对象语言特性请看之前的博客<a href="http://www.cnblogs.com/melodyzhy/p/4626380.html" target="_blank" rel="external">—&gt;也可以点我!&lt;—</a>)，在OC代码可以混入C语言代码，甚至是C++代码，也可以和swift进行混编。</p>
<p>好了，简介就说这么多&gt;_&lt;</p>
<p>先来个小问题：<strong>为什么OC要使用import引入头文件，import和include的区别？</strong></p>
<p>include 和 import 都是引入头文件</p>
<p>import引入的头文件，可以防止重复包含</p>
<p>include它是使用预处理指令防止重复包含，如果没有写预处理指令，则无法防止重复包含问题</p>
<p>还记得怎么使用预处理指令防止重复包含嘛</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#ifndef Zhy</div><div class="line">#define Zhy</div><div class="line"></div><div class="line">// 函数的声明</div><div class="line">void test(); </div><div class="line"></div><div class="line">#endif</div></pre></td></tr></table></figure>
<p>使用NSLog输出自带换行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;Hello World!&quot;);</div></pre></td></tr></table></figure>
<p>OC中相对C语言多了一个BOOL类型用来保存逻辑值，YES(真 1)   NO（假  0）</p>
<p><strong>OC中的异常捕捉机制</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@try &#123;</div><div class="line">         // 有可能会出错的代码</div><div class="line">         &lt;#Code that can potentially throw an exception#&gt;</div><div class="line">     &#125;</div><div class="line">     @catch (NSException *exception) &#123;</div><div class="line">         // 错误的处理方法</div><div class="line">         &lt;#Handle an exception thrown in the @try block#&gt;</div><div class="line">          NSLog(@&quot; %@ &quot;,exception);  // 打印出错误的信息</div><div class="line">     &#125;</div><div class="line">     @finally &#123;</div><div class="line">         // 无论是否有错都会执行</div><div class="line">        &lt;#Code that gets executed whether or not an exception is thrown#&gt;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>OC中类的创建以及在哪里定义成员变量，类方法和对象方法的声明和实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">// 人这个类的声明</div><div class="line">@interface Person : NSObject</div><div class="line">&#123;</div><div class="line">    // 成员变量</div><div class="line">    NSString *_name;</div><div class="line">    int _age;</div><div class="line">&#125;</div><div class="line">// 对象方法的声明</div><div class="line">- (void)duixiangfangfa;</div><div class="line">// 类方法的声明</div><div class="line">+ (void)leifangfa;</div><div class="line">@end</div><div class="line">// 人这个类的实现</div><div class="line">@implementation Person</div><div class="line">// 对象方法的实现</div><div class="line">- (void)duixiangfangfa</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;这是对象方法的实现&quot;);</div><div class="line">&#125;</div><div class="line">// 类方法的实现</div><div class="line">+ (void)leifangfa</div><div class="line">&#123;</div><div class="line">    NSLog(@&quot;这是类方法的实现&quot;);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>说一下创建对象的语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person *p = [Person new];</div></pre></td></tr></table></figure>
<p><strong>[Person new] 做了三件事情</strong></p>
<ol>
<li>申请内存空间</li>
<li>给实例变量初始化</li>
<li>返回空间的首地址</li>
</ol>
<p><strong>小问题：申请的空间在内存的哪个区？</strong></p>
<p>new 的时候申请的空间在内存的堆区(程序动态分配的内存空间)</p>
<p>实例变量保存在堆区，指针p保存在栈区，对象方法保存在代码区</p>
<p>堆区有一个_isa指针指向代码区，当对象要调用方法时，首先找p对应的堆区的空间，然后找到 _isa指针,再找到_isa指向的代码区的空间，然后到该空间中找 方法</p>
<p> 设计一个”学生“类</p>
<p>  1&gt; 成员变量</p>
<ul>
<li><p>姓名</p>
</li>
<li><p>生日</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">// 日期的结构体</div><div class="line">typedef struct &#123;</div><div class="line">    </div><div class="line">    // 年</div><div class="line">    int year;</div><div class="line">    // 月</div><div class="line">    int month;</div><div class="line">    // 日</div><div class="line">     int day;</div><div class="line">     </div><div class="line"> &#125;MyDate;</div><div class="line"> </div><div class="line"> // Student类的声明</div><div class="line"> @interface Student : NSObject</div><div class="line"> &#123;</div><div class="line">     @public</div><div class="line">   // 学生姓名</div><div class="line">     NSString *_name;</div><div class="line">     </div><div class="line">   // 学生生日</div><div class="line">     MyDate _birthday;  // 结构体变量</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> @end</div><div class="line"> </div><div class="line"> </div><div class="line"> // Student类的实现</div><div class="line"> @implementation Student</div><div class="line"> </div><div class="line"> @end</div><div class="line"> </div><div class="line"> </div><div class="line"> int main(int argc, const char * argv[]) &#123;</div><div class="line">     @autoreleasepool &#123;</div><div class="line">         </div><div class="line">         Student *stu = [Student new];</div><div class="line">         stu-&gt;_name = @&quot;阿衰&quot;;</div><div class="line">         </div><div class="line">         //第一种方法</div><div class="line">         stu-&gt;_birthday =(MyDate)&#123;1983,12,12&#125;;</div><div class="line">         //NSLog(@&quot;%d,%d,%d&quot;,stu-&gt;_birthday.year,stu-&gt;_birthday.month,stu-&gt;_birthday.day);</div><div class="line">         </div><div class="line">         //第二种方法：定义一个结构体变量</div><div class="line">         MyDate d1 = &#123;1981,11,11&#125;;  //定义结构体变量的同时进行初始化</div><div class="line">         stu-&gt;_birthday = d1;</div><div class="line">         </div><div class="line">         //第三种方法，逐个赋值</div><div class="line">         stu-&gt;_birthday.year = 2014;</div><div class="line">         stu-&gt;_birthday.month = 12;</div><div class="line">         stu-&gt;_birthday.day = 11;</div><div class="line">         </div><div class="line">         NSLog(@&quot;%d,%d,%d&quot;,stu-&gt;_birthday.year,stu-&gt;_birthday.month,stu-&gt;_birthday.day);</div><div class="line">     &#125;</div><div class="line">     return 0;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>这里主要说明的是调用结构体时的方法</p>
<p>NSString类的用法</p>
<p>NSString是OC中字符串处理的类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString *s = @&quot;zzzzzzzzzzzzzz &quot;;</div><div class="line">NSString *s1 = [NSString stringWithFormat:@&quot;%d&quot;,i];</div></pre></td></tr></table></figure>
<p>NSString字符串的长度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> NSString *s1 = @&quot;zzz&quot;;</div><div class="line"> NSUInteger len = [s1 length];  // 3</div><div class="line">// 中文字符在NSString中也占1个字节</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Objective-C简称OC，是一款可以开发Mac OS X平台和iOS平台应用程序的开发语言，目前最新的swift语言也可以开发以上两平台的应用。&lt;/p&gt;
&lt;p&gt;OC是面对对象的语言(OC面对对象语言特性请看之前的博客&lt;a href=&quot;http://www.cnblog
    
    </summary>
    
    
      <category term="Objective-C" scheme="http://MelodyZhy.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>static 和 extern</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/static%E5%92%8Cextern/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/static和extern/</id>
    <published>2017-08-01T06:32:03.000Z</published>
    <updated>2017-08-01T06:33:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>static 和 extern 修饰局部变量</p>
<p>static修饰局部变量：</p>
<p>作用：  </p>
<p>1、static定义的变量的作用域会得到延长</p>
<p>2、static定义变量的语句只会被执行一次</p>
<p> extern不能够修饰局部变量的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span> <span class="params">(<span class="keyword">int</span> num)</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">0</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</div><div class="line">    n++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line"><span class="function"></span>&#123;</div><div class="line">     test();   <span class="comment">// 输出结果为0</span></div><div class="line">     test();   <span class="comment">// 输出结果为1</span></div><div class="line">     test();   <span class="comment">// 输出结果为2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  static 对全局变量的作用（内部变量）</p>
<p>​          static修饰的全局变量，表示该全局变量只能在当前文件中使用，而不能在其他文件中使用</p>
<p>​          在不同的文件中，使用static可以声明的同名的变量</p>
<p>extern 对全局变量的作用</p>
<p>​          extern修饰的全局变量，表示当前变量可以在本文件中使用，也可以在</p>
<p>​          其他文件中使用</p>
<p>​          extern声明的全局变量在不同的文件中不能同名（两个文件须由包含关系）</p>
<p> static 和 extern对函数的作用</p>
<p>​      static 修饰的函数，是一个内部函数（只能在定义的那个文件中去使用）</p>
<p>​      extern 声明的函数，可以在定义文件中使用，也可以在其他文件中使用</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;static 和 extern 修饰局部变量&lt;/p&gt;
&lt;p&gt;static修饰局部变量：&lt;/p&gt;
&lt;p&gt;作用：  &lt;/p&gt;
&lt;p&gt;1、static定义的变量的作用域会得到延长&lt;/p&gt;
&lt;p&gt;2、static定义变量的语句只会被执行一次&lt;/p&gt;
&lt;p&gt; extern不能够修饰局
    
    </summary>
    
    
      <category term="static和extern" scheme="http://MelodyZhy.github.io/tags/static%E5%92%8Cextern/"/>
    
  </entry>
  
  <entry>
    <title>内存分区</title>
    <link href="http://MelodyZhy.github.io/2017/08/01/%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA/"/>
    <id>http://MelodyZhy.github.io/2017/08/01/内存分区/</id>
    <published>2017-08-01T06:31:24.000Z</published>
    <updated>2017-08-01T06:31:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>内存有五大区域</p>
<p>从高地址到低地址分别为：栈、堆、BBS段、数据段、代码段</p>
<p>提示：栈和堆是运行时分配，BBS段、数据段、代码段是编译器分配</p>
<p><strong>BBS段</strong>：通常是指用来存放程序中未初始化的全局变量和静态变量</p>
<p><strong>数据段</strong>：通常是指用来存放程序中已经初始化的全局变量和静态变量、字符串常量等</p>
<p><strong>代码段</strong>：通常是指用来存放程序执行代码的一块内存区域</p>
<p><strong>堆</strong>：是用于存放进程运行中被动态分配的内存段（调用malloc函数，新分配的内存动态添加到堆上；调用free函数，释放内存从堆中删除）</p>
<p><strong>栈</strong>：又称堆栈，是用户存放程序临时创建的局部变量</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;内存有五大区域&lt;/p&gt;
&lt;p&gt;从高地址到低地址分别为：栈、堆、BBS段、数据段、代码段&lt;/p&gt;
&lt;p&gt;提示：栈和堆是运行时分配，BBS段、数据段、代码段是编译器分配&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;BBS段&lt;/strong&gt;：通常是指用来存放程序中未初始化的全局变量和静态变量
    
    </summary>
    
    
      <category term="内存" scheme="http://MelodyZhy.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
</feed>
