<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MelodyZhy的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://MelodyZhy.github.io/"/>
  <updated>2018-03-22T07:23:56.779Z</updated>
  <id>http://MelodyZhy.github.io/</id>
  
  <author>
    <name>庄 颖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于UITableView的reloadData调用</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/%E5%85%B3%E4%BA%8EUITableView%E7%9A%84reloadData%E8%B0%83%E7%94%A8/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/关于UITableView的reloadData调用/</id>
    <published>2018-03-22T07:21:44.000Z</published>
    <updated>2018-03-22T07:23:56.779Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、问题"><a href="#一、问题" class="headerlink" title="一、问题"></a>一、问题</h3><p>很多时候需要在tableView执行reloadData后做一些事情，但是我们把代码直接下载[tableView reloadData]之后真的有用么，如果不是那么reloadData方式到底是异步执行还是同步，他与当前的runloop又有什么关系呢，下面我们来一一探讨这些问题</p>
<h3 id="二、分析"><a href="#二、分析" class="headerlink" title="二、分析"></a>二、分析</h3><h4 id="1、写在reloadData之后的代码是否是在tableView刷新之后执行的"><a href="#1、写在reloadData之后的代码是否是在tableView刷新之后执行的" class="headerlink" title="1、写在reloadData之后的代码是否是在tableView刷新之后执行的"></a>1、写在reloadData之后的代码是否是在tableView刷新之后执行的</h4><p>验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;tableView reload start&quot;);</div><div class="line">[self.tableView reloadData];</div><div class="line">NSLog(@&quot;tableView reload complete&quot;);</div></pre></td></tr></table></figure>
<p>结论：在reloadData之后的代码会在tableView刷新之前执行</p>
<h4 id="2、reloadData的调用到底是异步还是同步呢"><a href="#2、reloadData的调用到底是异步还是同步呢" class="headerlink" title="2、reloadData的调用到底是异步还是同步呢"></a>2、reloadData的调用到底是异步还是同步呢</h4><p>验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;tableView reload start&quot;);</div><div class="line">[self.tableView reloadData];</div><div class="line">NSLog(@&quot;tableView reload complete&quot;);</div><div class="line">sleep(5);</div></pre></td></tr></table></figure>
<p>结论：reloadData是一个同步执行，只不过受runloop影响了执行顺序</p>
<h4 id="3、reloadData与当前runloop有什么关系"><a href="#3、reloadData与当前runloop有什么关系" class="headerlink" title="3、reloadData与当前runloop有什么关系"></a>3、reloadData与当前runloop有什么关系</h4><p>验证：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">- (void)runLoopObsevers&#123;</div><div class="line">    CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(),kCFRunLoopAllActivities,YES,0, ^(CFRunLoopObserverRef observer,CFRunLoopActivity activity) &#123;</div><div class="line">        switch (activity) &#123;</div><div class="line">            case kCFRunLoopEntry:</div><div class="line">                NSLog(@&quot;即将进入Loop&quot;);</div><div class="line">                break;</div><div class="line">            case kCFRunLoopBeforeTimers:</div><div class="line">                NSLog(@&quot;即将处理 Timer&quot;);</div><div class="line">                break;</div><div class="line">            case kCFRunLoopBeforeSources:</div><div class="line">                NSLog(@&quot;即将处理 Source&quot;);</div><div class="line">                break;</div><div class="line">            case kCFRunLoopBeforeWaiting:</div><div class="line">                NSLog(@&quot;即将进入休眠&quot;);</div><div class="line">                break;</div><div class="line">            case kCFRunLoopAfterWaiting:</div><div class="line">                NSLog(@&quot;刚从休眠中唤醒&quot;);</div><div class="line">                break;</div><div class="line">            case kCFRunLoopExit:</div><div class="line">                NSLog(@&quot;即将退出Loop&quot;);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    CFRunLoopAddObserver(CFRunLoopGetMain(), observer,kCFRunLoopDefaultMode);</div><div class="line">    CFRelease(observer);</div><div class="line">&#125;</div><div class="line">NSLog(@&quot;tableView reload start&quot;);</div><div class="line">[self.tableView reloadData];</div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;tableView reload complete&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>结论：runloop会优先处理reloadData方法，然后去处理block里面的内容</p>
<h3 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 最终执行代码</div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">    NSLog(@&quot;tableView reload start&quot;);</div><div class="line">    [self.tableView reloadData];</div><div class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">        NSLog(@&quot;tableView reload complete&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一、问题&quot;&gt;&lt;a href=&quot;#一、问题&quot; class=&quot;headerlink&quot; title=&quot;一、问题&quot;&gt;&lt;/a&gt;一、问题&lt;/h3&gt;&lt;p&gt;很多时候需要在tableView执行reloadData后做一些事情，但是我们把代码直接下载[tableView reloa
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://MelodyZhy.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>CMPedometer</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/CMPedometer/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/CMPedometer/</id>
    <published>2018-03-22T07:18:37.000Z</published>
    <updated>2018-03-22T07:20:02.092Z</updated>
    
    <content type="html"><![CDATA[<h4 id="CMPedometer用法"><a href="#CMPedometer用法" class="headerlink" title="CMPedometer用法"></a>CMPedometer用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;CoreMotion/CoreMotion.h&gt;</div><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic,strong) CMPedometer *pedometer;</div><div class="line">@end</div><div class="line"> </div><div class="line">@implementation ViewController</div><div class="line"> </div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line"> </div><div class="line">    // 1. 创建计步器</div><div class="line">    self.pedometer = [[CMPedometer alloc]init];</div><div class="line"> </div><div class="line">    // 2. 开启计步器</div><div class="line">    [self.pedometer startPedometerUpdatesFromDate:[NSDate date] withHandler:^(CMPedometerData * _Nullable pedometerData, NSError * _Nullable error) &#123;</div><div class="line"> </div><div class="line"> </div><div class="line">        NSLog(@&quot;%@&quot;,pedometerData.numberOfSteps);</div><div class="line">    &#125;];</div><div class="line"> </div><div class="line">&#125;</div><div class="line"> </div><div class="line">@end</div></pre></td></tr></table></figure>
<h4 id="限定时间内获取计步数据"><a href="#限定时间内获取计步数据" class="headerlink" title="限定时间内获取计步数据"></a>限定时间内获取计步数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[self.pedometer queryPedometerDataFromDate:[NSDate date] toDate:[NSDate dateWithTimeIntervalSinceNow:10] withHandler:^(CMPedometerData * _Nullable pedometerData, NSError * _Nullable error) &#123;</div><div class="line"> </div><div class="line">    NSLog(@&quot;%@&quot;,pedometerData.numberOfSteps);</div><div class="line">&#125;];</div></pre></td></tr></table></figure>
<h4 id="CMPedometerData-包含属性"><a href="#CMPedometerData-包含属性" class="headerlink" title="CMPedometerData 包含属性"></a>CMPedometerData 包含属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@property(readonly, nonatomic) NSDate *startDate; 开始时间</div><div class="line">@property(readonly, nonatomic) NSDate *endDate;  结束时间</div><div class="line">@property(readonly, nonatomic) NSNumber *numberOfSteps; 计步</div><div class="line">@property(readonly, nonatomic, nullable) NSNumber *distance; 距离</div><div class="line">@property(readonly, nonatomic, nullable) NSNumber *floorsAscended;上了多少台阶</div><div class="line">@property(readonly, nonatomic, nullable) NSNumber *floorsDescended;下了多少台阶</div><div class="line">@property(readonly, nonatomic, nullable) NSNumber *currentPace;步速 s/m</div><div class="line">@property(readonly, nonatomic, nullable) NSNumber *currentCadence;节奏steps/s</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;CMPedometer用法&quot;&gt;&lt;a href=&quot;#CMPedometer用法&quot; class=&quot;headerlink&quot; title=&quot;CMPedometer用法&quot;&gt;&lt;/a&gt;CMPedometer用法&lt;/h4&gt;&lt;figure class=&quot;highlight plai
    
    </summary>
    
    
      <category term="Foundation框架" scheme="http://MelodyZhy.github.io/tags/Foundation%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>应用程序启动过程</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/应用程序启动过程/</id>
    <published>2018-03-22T07:16:33.000Z</published>
    <updated>2018-03-22T07:18:13.396Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/屏幕快照 2017-11-17 13.35.03.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">// 应用程序加载完毕</div><div class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;</div><div class="line">   </div><div class="line">    NSLog(@&quot;应用程序加载完毕&quot;);</div><div class="line">    return YES;</div><div class="line">&#125;</div><div class="line">// 即将变为不活跃状态 [失去焦点]</div><div class="line">- (void)applicationWillResignActive:(UIApplication *)application &#123;</div><div class="line">   </div><div class="line">    NSLog(@&quot;即将变为不活跃状态 [失去焦点]&quot;);</div><div class="line">   </div><div class="line">&#125;</div><div class="line">// 应用程序进入后台</div><div class="line">- (void)applicationDidEnterBackground:(UIApplication *)application &#123;</div><div class="line">   </div><div class="line">    NSLog(@&quot;应用程序进入后台&quot;);</div><div class="line">&#125;</div><div class="line">// 即将进入前台</div><div class="line">- (void)applicationWillEnterForeground:(UIApplication *)application &#123;</div><div class="line">   </div><div class="line">    NSLog(@&quot;即将进入前台&quot;);</div><div class="line">   </div><div class="line">&#125;</div><div class="line">// 应用变为活跃状态</div><div class="line">- (void)applicationDidBecomeActive:(UIApplication *)application &#123;</div><div class="line">   </div><div class="line">    NSLog(@&quot;应用变为活跃状态[获取焦点]&quot;);</div><div class="line">&#125;</div><div class="line">// 应用即将销毁</div><div class="line">- (void)applicationWillTerminate:(UIApplication *)application &#123;</div><div class="line">   </div><div class="line">    NSLog(@&quot;应用即将销毁&quot;);</div><div class="line">&#125;</div><div class="line">// 应用接收到内存警告</div><div class="line">- (void)applicationDidReceiveMemoryWarning:(UIApplication *)application &#123;</div><div class="line">   </div><div class="line">    NSLog(@&quot;应用接收到内存警告&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/屏幕快照 2017-11-17 13.35.03.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://MelodyZhy.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UIDevice的使用</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/UIDevice%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/UIDevice的使用/</id>
    <published>2018-03-22T07:14:55.000Z</published>
    <updated>2018-03-22T07:16:10.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、直接使用的方法"><a href="#1、直接使用的方法" class="headerlink" title="1、直接使用的方法"></a>1、直接使用的方法</h3><p>使用的时候需要导入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div></pre></td></tr></table></figure>
<p>使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[UIDevice currentDevice]</div></pre></td></tr></table></figure>
<p>即可获得单例，比如这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;%@&quot;,[UIDevice currentDevice].name);</div></pre></td></tr></table></figure>
<p>以下就是可以使用该单例获取的各类信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//获取当前设备单例</div><div class="line">+ (UIDevice *)currentDevice;</div><div class="line">//获取当前设备名称 </div><div class="line">@property(nonatomic,readonly,strong) NSString    *name;              // e.g. &quot;My iPhone&quot;</div><div class="line">//获取当前设备模式</div><div class="line">@property(nonatomic,readonly,strong) NSString    *model;             // e.g. @&quot;iPhone&quot;, @&quot;iPod touch&quot;</div><div class="line">//获取本地化的当前设备模式</div><div class="line">@property(nonatomic,readonly,strong) NSString    *localizedModel;    // localized version of model</div><div class="line">//获取系统名称</div><div class="line">@property(nonatomic,readonly,strong) NSString    *systemName;        // e.g. @&quot;iOS&quot;</div><div class="line">//获取系统版本</div><div class="line">@property(nonatomic,readonly,strong) NSString    *systemVersion;     // e.g. @&quot;4.0&quot;</div><div class="line">//获取设备方向</div><div class="line">@property(nonatomic,readonly) UIDeviceOrientation orientation;       </div><div class="line">//获取设备UUID对象</div><div class="line">@property(nullable, nonatomic,readonly,strong) NSUUID      *identifierForVendor;</div><div class="line">//是否开启监测电池状态 开启后 才可以正常获取电池状态</div><div class="line">@property(nonatomic,getter=isBatteryMonitoringEnabled) BOOL batteryMonitoringEnabled NS_AVAILABLE_IOS(3_0);  // default is NO</div><div class="line">//获取电池状态</div><div class="line">@property(nonatomic,readonly) UIDeviceBatteryState          batteryState NS_AVAILABLE_IOS(3_0);  </div><div class="line">//获取电量</div><div class="line">@property(nonatomic,readonly) float                         batteryLevel NS_AVAILABLE_IOS(3_0);</div></pre></td></tr></table></figure>
<p>获取的设备方向的类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, UIDeviceOrientation) &#123;</div><div class="line">    UIDeviceOrientationUnknown,</div><div class="line">    UIDeviceOrientationPortrait,            // home键在下</div><div class="line">    UIDeviceOrientationPortraitUpsideDown,  // home键在上</div><div class="line">    UIDeviceOrientationLandscapeLeft,       // home键在右</div><div class="line">    UIDeviceOrientationLandscapeRight,      // home键在左</div><div class="line">    UIDeviceOrientationFaceUp,              // 屏幕朝上</div><div class="line">    UIDeviceOrientationFaceDown             // 屏幕朝下</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>电池状态的类型枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">typedef NS_ENUM(NSInteger, UIDeviceBatteryState) &#123;</div><div class="line">    UIDeviceBatteryStateUnknown,</div><div class="line">    UIDeviceBatteryStateUnplugged,   // 放电状态</div><div class="line">    UIDeviceBatteryStateCharging,    // 充电未充满状态</div><div class="line">    UIDeviceBatteryStateFull,        // 充电已充满</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>获取电池状态的时候，需要先把监视电池的功能打开，然后再开始检查状态，比如这样</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[UIDevice currentDevice].batteryMonitoringEnabled = YES;</div><div class="line">NSLog(@&quot;%f&quot;,[UIDevice currentDevice].batteryLevel);</div></pre></td></tr></table></figure>
<h3 id="2、需要函数调用的枚举"><a href="#2、需要函数调用的枚举" class="headerlink" title="2、需要函数调用的枚举"></a>2、需要函数调用的枚举</h3><p>这个类型中还有这几个状态的枚举</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//设备方向改变时发送的通知</div><div class="line">UIKIT_EXTERN NSString *const UIDeviceOrientationDidChangeNotification;</div><div class="line">//电池状态改变时发送的通知</div><div class="line">UIKIT_EXTERN NSString *const UIDeviceBatteryStateDidChangeNotification   NS_AVAILABLE_IOS(3_0);</div><div class="line">//电量改变时发送的通知</div><div class="line">UIKIT_EXTERN NSString *const UIDeviceBatteryLevelDidChangeNotification   NS_AVAILABLE_IOS(3_0);</div><div class="line">//距离传感器状态改变时发送的通知</div><div class="line">UIKIT_EXTERN NSString *const UIDeviceProximityStateDidChangeNotification NS_AVAILABLE_IOS(3_0);</div></pre></td></tr></table></figure>
<p>这几个状态添加通知使用，比如设备方向变得时候，这样调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(change) name:UIDeviceOrientationDidChangeNotification object:nil];</div><div class="line"></div><div class="line">-(void)change&#123;</div><div class="line">    NSLog(@&quot;change&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样当设备方向变的时候会发通知。这样的话只要设备的方向改变就会发送这个通知。</p>
<p>当然还有这两个函数可以控制检查设备的方向的时机，如果不用时时刻刻监视屏幕旋转方向，可以合理使用这两个函数，省电省内存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">- (void)beginGeneratingDeviceOrientationNotifications __TVOS_PROHIBITED;      // nestable</div><div class="line">- (void)endGeneratingDeviceOrientationNotifications __TVOS_PROHIBITED;</div></pre></td></tr></table></figure>
<p>当需要监视的时候，调用打开，不需要监视的时候关闭，比如这样用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[[UIDevice currentDevice] beginGeneratingDeviceOrientationNotifications];</div><div class="line">[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(change) name:UIDeviceOrientationDidChangeNotification object:nil];</div><div class="line">-(void)change&#123;</div><div class="line">    NSLog(@&quot;change&quot;);</div><div class="line">    [[UIDevice currentDevice] endGeneratingDeviceOrientationNotifications];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样当关闭监视的时候，就不会再调用change函数了，这个测试了下，会打印两次change，应该是横竖屏各切换一次之后不调用。</p>
<p>可以用这个函数来判断监视是否打开了，返回的是bool值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[UIDevice currentDevice].generatesDeviceOrientationNotifications</div></pre></td></tr></table></figure>
<h3 id="3、手机距离传感器的使用"><a href="#3、手机距离传感器的使用" class="headerlink" title="3、手机距离传感器的使用"></a>3、手机距离传感器的使用</h3><p>手机距离传感器的作用就像比如接电话的时候靠近耳朵的话，手机熄灭屏幕等。</p>
<p>可以这么使用，首先需要打开手机距离传感器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[UIDevice currentDevice].proximityMonitoringEnabled=YES;</div></pre></td></tr></table></figure>
<p>然后添加当距离开始变化的时候的通知和函数调用即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[[NSNotificationCenter defaultCenter]addObserver:self selector:@selector(notice) name:UIDeviceProximityStateDidChangeNotification object:nil];</div><div class="line">-(void)notice&#123;</div><div class="line">    if ([UIDevice currentDevice].proximityState) &#123;</div><div class="line">        NSLog(@&quot;近距离&quot;);</div><div class="line">    &#125;else&#123;</div><div class="line">        NSLog(@&quot;远距离&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1、直接使用的方法&quot;&gt;&lt;a href=&quot;#1、直接使用的方法&quot; class=&quot;headerlink&quot; title=&quot;1、直接使用的方法&quot;&gt;&lt;/a&gt;1、直接使用的方法&lt;/h3&gt;&lt;p&gt;使用的时候需要导入&lt;/p&gt;
&lt;figure class=&quot;highlight pla
    
    </summary>
    
    
      <category term="Foundation框架" scheme="http://MelodyZhy.github.io/tags/Foundation%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>控件ContentMode代码改变填充模式小结</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/%E6%8E%A7%E4%BB%B6ContentMode%E4%BB%A3%E7%A0%81%E6%94%B9%E5%8F%98%E5%A1%AB%E5%85%85%E6%A8%A1%E5%BC%8F%E5%B0%8F%E7%BB%93/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/控件ContentMode代码改变填充模式小结/</id>
    <published>2018-03-22T07:13:46.000Z</published>
    <updated>2018-03-22T07:14:25.315Z</updated>
    
    <content type="html"><![CDATA[<h4 id="在UIImageView的使用中-有时需要用代码设置其内图片内容的填充模式"><a href="#在UIImageView的使用中-有时需要用代码设置其内图片内容的填充模式" class="headerlink" title="在UIImageView的使用中,有时需要用代码设置其内图片内容的填充模式,"></a>在UIImageView的使用中,有时需要用代码设置其内图片内容的填充模式,</h4><h4 id="为方便以后工作方便查找使用-现把各种模式测试如下"><a href="#为方便以后工作方便查找使用-现把各种模式测试如下" class="headerlink" title="为方便以后工作方便查找使用,现把各种模式测试如下"></a>为方便以后工作方便查找使用,现把各种模式测试如下</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 测试图片内容填充模式</div><div class="line">static int a;</div><div class="line">-(void)test1&#123;</div><div class="line">    self.imageV.image = [UIImage imageNamed:@&quot;aa.jpg&quot;];</div><div class="line">    // 改变内部内容的填充方式</div><div class="line">    self.imageV.contentMode = a;</div><div class="line">    // 显示模式文字</div><div class="line">    UILabel *lab = [[UILabel alloc]initWithFrame:CGRectMake(0, 300, 375, 100)];</div><div class="line">    NSArray *arr = @[</div><div class="line">                      @&quot;UIViewContentModeScaleToFill&quot;,      // 拉伸自适应填满整个视图</div><div class="line">                      @&quot;UIViewContentModeScaleAspectFit&quot;,   // 自适应比例大小显示</div><div class="line">                      @&quot;UIViewContentModeScaleAspectFill&quot;,  // 原始大小显示</div><div class="line">                      @&quot;UIViewContentModeRedraw&quot;,           // 尺寸改变时重绘</div><div class="line">                      @&quot;UIViewContentModeCenter&quot;,           // 中间</div><div class="line">                      @&quot;UIViewContentModeTop&quot;,              // 顶部</div><div class="line">                      @&quot;UIViewContentModeBottom&quot;,           // 底部</div><div class="line">                      @&quot;UIViewContentModeLeft&quot;,             // 中间贴左</div><div class="line">                      @&quot;UIViewContentModeRight&quot;,            // 中间贴右</div><div class="line">                      @&quot;UIViewContentModeTopLeft&quot;,          // 贴左上</div><div class="line">                      @&quot;UIViewContentModeTopRight&quot;,         // 贴右上</div><div class="line">                      @&quot;UIViewContentModeBottomLeft&quot;,       // 贴左下</div><div class="line">                      @&quot;UIViewContentModeBottomRight&quot;,      // 贴右下</div><div class="line">                     ];</div><div class="line">    lab.text = arr[a++];</div><div class="line">    lab.font = [UIFont systemFontOfSize:20];</div><div class="line">    [self.lab removeFromSuperview];</div><div class="line">    [self.imageV addSubview:lab];</div><div class="line">    self.lab = lab;</div><div class="line">    NSLog(@&quot;%s 模式%d&quot;,__func__,a);</div><div class="line">    if (a == 13) a = 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;在UIImageView的使用中-有时需要用代码设置其内图片内容的填充模式&quot;&gt;&lt;a href=&quot;#在UIImageView的使用中-有时需要用代码设置其内图片内容的填充模式&quot; class=&quot;headerlink&quot; title=&quot;在UIImageView的使用中,有
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://MelodyZhy.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>HTTP状态码</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/HTTP状态码/</id>
    <published>2018-03-22T07:12:45.000Z</published>
    <updated>2018-03-22T07:13:13.023Z</updated>
    
    <content type="html"><![CDATA[<p>1xx消息</p>
<p>这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码代表的响应都是信息性的，标示客户应该采取的其他行动。</p>
<p>100 Continue<br>​    客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。<br>101 Switching Protocols<br>​    服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。<br>102 Processing<br>​    由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。</p>
<p>2xx成功</p>
<p>这一类型的状态码，代表请求已成功被服务器接收、理解、并接受。</p>
<p>200 OK<br>​    请求已成功，请求所希望的响应头或数据体将随此响应返回。<br>201 Created<br>​    请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。假如需要的资源无法及时创建的话，应当返回’202 Accepted’。<br>202 Accepted<br>​    服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。<br>203 Non-Authoritative Information<br>​    服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。<br>204 No Content<br>​    服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。<br>​    如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。<br>​    由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。<br>205 Reset Content<br>​    服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。<br>​    与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。<br>206 Partial Content<br>​    服务器已经成功处理了部分GET请求。类似于FlashGet或者迅雷这类的HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。<br>​    该请求必须包含Range头信息来指示客户端希望得到的内容范围，并且可能包含If-Range来作为请求条件。<br>​    响应必须包含如下的头部域：</p>
<p>​        Content-Range用以指示本次响应中返回的内容的范围；如果是Content-Type为multipart/byteranges的多段下载，则每一multipart段中都应包含Content-Range域用以指示本段的内容范围。假如响应中包含Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。<br>​        Date<br>​        ETag和／或Content-Location，假如同样的请求本应该返回200响应。<br>​        Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。</p>
<p>​    假如本响应请求使用了If-Range强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了If-Range弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。<br>​    假如ETag或Last-Modified头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。<br>​    任何不支持Range以及Content-Range头的缓存都禁止缓存206响应返回的内容。<br>207 Multi-Status<br>​    由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p>
<p>3xx重定向</p>
<p>这类状态码代表需要客户端采取进一步的操作才能完成请求。通常，这些状态码用来重定向，后续的请求地址（重定向目标）在本次响应的Location域中指明。</p>
<p>当且仅当后续的请求所使用的方法是GET或者HEAD时，用户浏览器才可以在没有用户介入的情况下自动提交所需要的后续请求。客户端应当自动监测无限循环重定向（例如：A→B→C→……→A或A→A），因为这会导致服务器和客户端大量不必要的资源消耗。按照HTTP/1.0版规范的建议，浏览器不应自动访问超过5次的重定向。</p>
<p>300 Multiple Choices<br>​    被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。<br>​    除非这是一个HEAD请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由Content-Type定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。<br>​    如果服务器本身已经有了首选的回馈选择，那么在Location中应当指明这个回馈的URI；浏览器可能会将这个Location值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。<br>301 Moved Permanently<br>​    被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。<br>​    新的永久性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>​    如果这不是一个GET或者HEAD请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>​    注意：对于某些使用HTTP/1.0协议的浏览器，当它们发送的POST请求得到了一个301响应的话，接下来的重定向请求将会变成GET方式。<br>302 Found<br>​    请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>​    新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>​    如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。<br>​    注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用GET方式访问在Location中规定的URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。<br>303 See Other<br>​    对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的URI不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。<br>​    新的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。<br>​    注意：许多HTTP/1.1版以前的浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。<br>304 Not Modified<br>​    如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。<br>​    该响应必须包含以下的头信息：</p>
<p>​        Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将Date字段添加到接收到的响应头中去（正如RFC2068中规定的一样），缓存机制将会正常工作。<br>​        ETag和／或Content-Location，假如同样的请求本应返回200响应。<br>​        Expires, Cache-Control，和／或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。</p>
<p>​    假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的GET请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。<br>​    假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。<br>​    假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。<br>305 Use Proxy<br>​    被请求的资源必须通过指定的代理才能被访问。Location域中将给出指定的代理所在的URI信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能创建305响应。<br>​    注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器创建。忽视这些限制可能导致严重的安全后果。<br>306 Switch Proxy<br>​    在最新版的规范中，306状态码已经不再被使用。<br>307 Temporary Redirect<br>​    请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。<br>​    新的临时性的URI应当在响应的Location域中返回。除非这是一个HEAD请求，否则响应的实体中应当包含指向新的URI的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的URI发出访问请求。<br>​    如果这不是一个GET或者HEAD请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。</p>
<p>4xx客户端错误</p>
<p>这类的状态码代表了客户端看起来可能发生了错误，妨碍了服务器的处理。除非响应的是一个HEAD请求，否则服务器就应该返回一个解释当前错误状况的实体，以及这是临时的还是永久性的状况。这些状态码适用于任何请求方法。浏览器应当向用户显示任何包含在此类错误响应中的实体内容。</p>
<p>如果错误发生时客户端正在传送数据，那么使用TCP的服务器实现应当仔细确保在关闭客户端与服务器之间的连接之前，客户端已经收到了包含错误信息的数据包。如果客户端在收到错误信息后继续向服务器发送数据，服务器的TCP栈将向客户端发送一个重置数据包，以清除该客户端所有还未识别的输入缓冲，以免这些数据被服务器上的应用程序读取并干扰后者。</p>
<p>400 Bad Request<br>​    由于包含语法错误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。<br>401 Unauthorized<br>​    当前请求需要用户验证。该响应必须包含一个适用于被请求资源的WWW-Authenticate信息头用以询问用户信息。客户端可以重复提交一个包含恰当的Authorization头信息的请求。如果当前请求已经包含了Authorization证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。<br>402 Payment Required<br>​    该状态码是为了将来可能的需求而预留的。<br>403 Forbidden<br>​    服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个HEAD请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。<br>404 Not Found<br>​    请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。<br>405 Method Not Allowed<br>​    请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow头信息用以表示出当前资源能够接受的请求方法的列表。<br>​    鉴于PUT，DELETE方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。<br>406 Not Acceptable<br>​    请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。<br>​    除非这是一个HEAD请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由Content-Type头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。<br>407 Proxy Authentication Required<br>​    与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个Proxy-Authenticate用以进行身份询问。客户端可以返回一个Proxy-Authorization信息头用以验证。参见RFC 2617。<br>408 Request Timeout<br>​    请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。<br>409 Conflict<br>​    由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。<br>​    冲突通常发生于对PUT请求的处理中。例如，在采用版本检查的环境下，某次PUT提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。<br>410 Gone<br>​    被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。<br>​    410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。<br>411 Length Required<br>​    服务器拒绝在没有定义Content-Length头的情况下接受请求。在添加了表明请求消息体长度的有效Content-Length头之后，客户端可以再次提交该请求。<br>412 Precondition Failed<br>​    服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。<br>413 Request Entity Too Large<br>​    服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。<br>​    如果这个状况是临时的，服务器应当返回一个Retry-After的响应头，以告知客户端可以在多少时间以后重新尝试。<br>414 Request-URI Too Long<br>​    请求的URI长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：</p>
<p>​        本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。<br>​        重定向URI“黑洞”，例如每次重定向把旧的URI作为新的URI的一部分，导致在若干次重定向后URI超长。<br>​        客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的URI，当GET后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。</p>
<p>415 Unsupported Media Type<br>​    对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。<br>416 Requested Range Not Satisfiable<br>​    如果请求中包含了Range请求头，并且Range中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义If-Range请求头，那么服务器就应当返回416状态码。<br>​    假如Range使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个Content-Range实体头，用以指明当前资源的长度。这个响应也被禁止使用multipart/byteranges作为其Content-Type。<br>417 Expectation Failed<br>​    在请求头Expect中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect的内容无法被满足。<br>418 I’m a teapot<br>​    本操作码是在1998年作为IETF的传统愚人节笑话, 在RFC 2324 超文本咖啡壶控制协议中定义的，并不需要在真实的HTTP服务器中定义。<br>421 There are too many connections from your internet address<br>​    从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。<br>422 Unprocessable Entity<br>​    请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）<br>423 Locked<br>​    当前资源被锁定。（RFC 4918 WebDAV）<br>424 Failed Dependency<br>​    由于之前的某个请求发生的错误，导致当前请求失败，例如PROPPATCH。（RFC 4918 WebDAV）<br>425 Unordered Collection<br>​    在WebDav Advanced Collections草案中定义，但是未出现在《WebDAV顺序集协议》（RFC 3658）中。<br>426 Upgrade Required<br>​    客户端应当切换到TLS/1.0。（RFC 2817）<br>449 Retry With<br>​    由微软扩展，代表请求应当在执行完适当的操作后进行重试。</p>
<p>5xx服务器错误</p>
<p>这类状态码代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬件资源无法完成对请求的处理。除非这是一个HEAD请求，否则服务器应当包含一个解释当前错误状态以及这个状况是临时的还是永久的解释信息实体。浏览器应当向用户展示任何在当前响应中被包含的实体。</p>
<p>这些状态码适用于任何响应方法。</p>
<p>500 Internal Server Error<br>​    服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。<br>501 Not Implemented<br>​    服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。<br>502 Bad Gateway<br>​    作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>503 Service Unavailable<br>​    由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个Retry-After头用以标明这个延迟时间。如果没有给出这个Retry-After信息，那么客户端应当以处理500响应的方式处理它。<br>504 Gateway Timeout<br>​    作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。<br>​    注意：某些代理服务器在DNS查询超时时会返回400或者500错误<br>505 HTTP Version Not Supported<br>​    服务器不支持，或者拒绝支持在请求中使用的HTTP版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。<br>506 Variant Also Negotiates<br>​    由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。<br>507 Insufficient Storage<br>​    服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV（RFC 4918）<br>509 Bandwidth Limit Exceeded<br>​    服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。<br>510 Not Extended<br>​    获取资源所需要的策略并没有没满足。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1xx消息&lt;/p&gt;
&lt;p&gt;这一类型的状态码，代表请求已被接受，需要继续处理。这类响应是临时响应，只包含状态行和某些可选的响应头信息，并以空行结束。由于HTTP/1.0协议中没有定义任何1xx状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送1xx响应。 这些状态码
    
    </summary>
    
    
      <category term="HTTP" scheme="http://MelodyZhy.github.io/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>控制器之间跳转那点事</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E8%B7%B3%E8%BD%AC%E9%82%A3%E7%82%B9%E4%BA%8B/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/控制器之间跳转那点事/</id>
    <published>2018-03-22T07:11:41.000Z</published>
    <updated>2018-03-22T07:12:27.346Z</updated>
    
    <content type="html"><![CDATA[<p>UINavigationController先pop再push，push操作将无效<br>解决方案是：</p>
<ol>
<li>从self.navigationController.viewControllers中拿出需要保留的View Controller放到一个数组中</li>
<li>向数组中添加需要push的View Controller</li>
<li>调用[self.navigationController setViewControllers:array animated:YES]</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">RetainTableViewController *retain = [[RetainTableViewController alloc] init];</div><div class="line"></div><div class="line">NSMutableArray *vcArray = [NSMutableArray array];</div><div class="line"></div><div class="line">[vcArray addObject:self.navigationController.viewControllers[0]];</div><div class="line"></div><div class="line">[vcArray addObject:retain];</div><div class="line"></div><div class="line">[self.navigationController setViewControllers:vcArray animated:YES];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;UINavigationController先pop再push，push操作将无效&lt;br&gt;解决方案是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从self.navigationController.viewControllers中拿出需要保留的View Controller放到一个数组中
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://MelodyZhy.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>UITextField每隔4位输入一个空格</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/UITextField%E6%AF%8F%E9%9A%944%E4%BD%8D%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%A0%BC/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/UITextField每隔4位输入一个空格/</id>
    <published>2018-03-22T07:10:14.000Z</published>
    <updated>2018-03-22T07:10:37.549Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123;</div><div class="line">        // 四位加一个空格</div><div class="line">        if ([string isEqualToString:@&quot;&quot;]) &#123; // 删除字符</div><div class="line">            if ((textField.text.length - 2) % 5 == 0) &#123;</div><div class="line">                textField.text = [textField.text substringToIndex:textField.text.length - 1];</div><div class="line">            &#125;</div><div class="line">            return YES;</div><div class="line">        &#125; else &#123;</div><div class="line">            if (textField.text.length % 5 == 0) &#123;</div><div class="line">                textField.text = [NSString stringWithFormat:@&quot;%@ &quot;, textField.text];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
      <category term="UI" scheme="http://MelodyZhy.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>iOS Crash Log分析</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/iOS-Crash-Log%E5%88%86%E6%9E%90/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/iOS-Crash-Log分析/</id>
    <published>2018-03-22T07:09:22.000Z</published>
    <updated>2018-03-22T07:09:49.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Crash-Log的获取"><a href="#Crash-Log的获取" class="headerlink" title="Crash Log的获取"></a>Crash Log的获取</h2><h3 id="第一种"><a href="#第一种" class="headerlink" title="第一种"></a>第一种</h3><p>目录： ~/Library/Logs/CrashReporter/MobileDevice/   选择你的设备</p>
<p>你会发现一堆.crash文件和.ips文件</p>
<h3 id="第二种"><a href="#第二种" class="headerlink" title="第二种"></a>第二种</h3><p>连接手机</p>
<p>通过Xcode获取到崩溃日志，方法是Xcode-&gt;Window→Devices</p>
<h2 id="Crash-Log的分析"><a href="#Crash-Log的分析" class="headerlink" title="Crash Log的分析"></a>Crash Log的分析</h2><p>接下来就让我们对已经符号化以后的crash文件进行分析。<br>网上已有的分类比较多，我这里直接把我目前一般找crash原因的模块展示出来，其他的就留待各位自己去研究了，分别是设备和crash信息、异常信息、线程信息<br>1、首先是设备和crash信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Incident Identifier: F3573A...E2F244A              //crash的id</div><div class="line">CrashReporter Key:   cc2298...es77eeb              //crash的设备id</div><div class="line">Hardware Model:      iPhone7,2                     //手机型号</div><div class="line">Process:             [AppName] [1816]              //APP的名字[进程的id]</div><div class="line">Path:                /private/.../Application...   //APP的位置</div><div class="line">Identifier:          com....                       //bundle ID</div><div class="line">Version:             14 (2.3.5)                    //版本号</div><div class="line">Code Type:           ARM-64 (Native)               //app的应用架构之类不大清楚，^_^</div><div class="line">Parent Process:      launchd [1]</div><div class="line"></div><div class="line">Date/Time:           2015-10-26 15:03:29.29 +0800    //crash发生时间</div><div class="line">Launch Time:         2015-10-26 14:58:28.28 +0800    //进入应用时间</div><div class="line">OS Version:          iOS 9.1 (13B143)                //iOS版本</div><div class="line">Report Version:      105</div></pre></td></tr></table></figure>
<p>当你有大量的crash文件的时候，你就可以对crash文件里面的 Hardware Model，Version ， OS Version等进行分类，就可以获知到很多信息，比如说，你会知道crash一般发生原因是因为手机型号，还是App版本，或者还是手机版本的原因。（笔者暂时没碰过大量的crash文件，所以只能纸上谈兵了^_^）</p>
<p>2、其次是异常信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Exception Type:  EXC_BAD_ACCESS (SIGABRT)                      //异常的类型</div><div class="line">Exception Subtype: KERN_INVALID_ADDRESS at 0x0000000000000118  //异常子类型</div><div class="line">Triggered by Thread:  0                    //异常发生的线程(0为主线程，其他为子线程)</div></pre></td></tr></table></figure>
<p>3、线程信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Last Exception Backtrace:</div><div class="line">0   CoreFoundation                    0x182780f48 __exceptionPreprocess + 124</div><div class="line">1   libobjc.A.dylib                   0x197333f80 objc_exception_throw + 56</div><div class="line">2   CoreFoundation                    0x182780e90 +[NSException raise:format:] + 120</div><div class="line">3   [AppName]                            0x100c42a40 UmengSignalHandler + 144</div><div class="line">4   libsystem_platform.dylib          0x197d6193c _sigtramp + 52</div><div class="line">5   [AppName]                            0x1005d9f38 CScopePtr&lt;IAVGAudioLogic&gt;::operator IAVGAudioLogic*&lt;IAVGAudioLogic&gt;() (xprefc.h:165)</div><div class="line">6   [AppName]                            0x1005d3b8c tencent::av::AVRoomMultiImpl::GetAudioLogic() (av_room_multi_impl.h:119)</div><div class="line">7   [AppName]                            0x10057076c tencent::av::AVAudioCtrlImpl::SetAudioOutputMode(int) (av_audio_ctrl_impl.cpp:443)</div><div class="line">8   [AppName]                            0x10044dc3c -[AVBasicManager changeSpeakerMode:] (AVManager.mm:525)</div><div class="line">9   [AppName]                            0x100296e1c -[KTQAVRoom enableSpeakerMode:] (KTQAVRoom.m:345)</div><div class="line">10  [AppName]                            0x1002970d0 -[KTQAVRoom settingSpeaker:] (KTQAVRoom.m:362)</div><div class="line">11  [AppName]                            0x1003d5464 -[KTChatView onAudioNotificationReceived:] (KTChatView.m:685)</div></pre></td></tr></table></figure>
<p>恩。。。这符号化以后应该可以看懂了吧，这个crash的问题应该是腾讯第三方的一个冲突吧233</p>
<p>一般来说，通过异常信息和线程信息就可以找到crash的原因了。</p>
<h4 id="异常信息解读"><a href="#异常信息解读" class="headerlink" title="异常信息解读"></a><strong>异常信息解读</strong></h4><h5 id="1、Exception-Type（异常类型）"><a href="#1、Exception-Type（异常类型）" class="headerlink" title="1、Exception Type（异常类型）"></a>1、Exception Type（异常类型）</h5><ul>
<li><strong>Exception Type</strong>：通常包含Signal信号 和 EXC_BAD_ACCESS，NSRangeException等。</li>
</ul>
<table>
<thead>
<tr>
<th>异常类型</th>
<th>可能的原因</th>
<th>调试方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>EXC_CRASH</td>
<td>unrecognized selector</td>
<td>All Exception Point</td>
</tr>
<tr>
<td>EXC_BAD_ACCESS</td>
<td>内存访问错误</td>
<td>NSZombie</td>
</tr>
<tr>
<td>SIGSEGV</td>
<td>引用了released对象 / 引用未init的对象 / 数组越界/ 试图往没有写权限的内存地址写数据</td>
<td>NSZombie</td>
</tr>
<tr>
<td>SIGABRT</td>
<td>逻辑错误导致的Crash,比如尝试多次释放同一个没存</td>
<td>逻辑检查</td>
</tr>
<tr>
<td>SIGPIPE</td>
<td>TCP突然断开，再发送数据</td>
<td>添加signal（SIGPIPE，XX）</td>
</tr>
</tbody>
</table>
<h5 id="2、Exception-Code（异常编码）"><a href="#2、Exception-Code（异常编码）" class="headerlink" title="2、Exception Code（异常编码）"></a>2、Exception Code（异常编码）</h5><ul>
<li><strong>Exception Code</strong>：以一些文字开头，紧接着是一个或多个十六进制值。这些数值说明了Crash发生的本质。</li>
<li>从Exception Code中，可以区分出Crash是因为程序错误、非法内存访问还是其他原因。常见的异常编码如下表：</li>
</ul>
<table>
<thead>
<tr>
<th>异常编码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x8badf00d</td>
<td>ate bad food ，表示应用是因为发生watchdog超时而被iOS终止的。通常是应用花费太多时间而无法启动、终止或响应用系统事件。</td>
</tr>
<tr>
<td>0xdeadfa11</td>
<td>dead fall，用户强制退出。</td>
</tr>
<tr>
<td>0xbaaaaaad</td>
<td>用户按住Home键和音量键，获取当前内存状态，不代表崩溃。</td>
</tr>
<tr>
<td>0xbad22222</td>
<td>VoIP 应用因为过于频繁重启而被终止</td>
</tr>
<tr>
<td>0xc00010ff</td>
<td>cool off，因为太烫了被干掉</td>
</tr>
<tr>
<td>0xdead10cc</td>
<td>dead lock，表明应用因为在后台运行时占用系统资源（如通讯录数据库）</td>
</tr>
<tr>
<td>0xbbadbeef</td>
<td>bad beef，发生致命错误</td>
</tr>
</tbody>
</table>
<p><a href="http://www.jianshu.com/p/2e02502e2c84" target="_blank" rel="external">http://www.jianshu.com/p/2e02502e2c84</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Crash-Log的获取&quot;&gt;&lt;a href=&quot;#Crash-Log的获取&quot; class=&quot;headerlink&quot; title=&quot;Crash Log的获取&quot;&gt;&lt;/a&gt;Crash Log的获取&lt;/h2&gt;&lt;h3 id=&quot;第一种&quot;&gt;&lt;a href=&quot;#第一种&quot; class
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://MelodyZhy.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>解释垃圾回收的原理</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/%E8%A7%A3%E9%87%8A%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/解释垃圾回收的原理/</id>
    <published>2018-03-22T07:08:25.000Z</published>
    <updated>2018-03-22T07:08:57.465Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们知道，Android 手机通常使用 Java 来开发，而 Java 是使用垃圾回收这种内存管理方式。 那么，ARC 和垃圾回收对比，有什么优点和缺点？</p>
<p>考查点</p>
<p>此题其实是考查大家的知识面，虽然做 iOS 开发并不需要用到垃圾回收这种内存管理机制。但是垃圾回收被使用得非常普遍，不但有 Java，还包括 JavaScript, C#，Go 等语言。<br>如果两个候选人，一个人只会 iOS 开发，另一个人不但会 iOS 开发，对别的语言或技术也有兴趣了解，那我通常更倾向于后者。而且事实常常是，由于后者对计算机兴趣更浓，他在 iOS 上也通常专研得比前者更多。</p>
<p>垃圾回收简介</p>
<p>作为 iOS 开发者，了解一下这个世界上除了 ARC 之外最流行的内存管理方式，还是挺有价值的。所以我尽量简单给大家介绍一下。<br>垃圾回收（Garbage Collection，简称 GC）这种内存管理机制最早由图灵奖获得者 John McCarthy 在 1959 年提出，垃圾回收的理论主要基于一个事实：大部分的对象的生命期都很短。<br>所以，GC 将内存中的对象主要分成两个区域：Young 区和 Old 区。对象先在 Young 区被创建，然后如果经过一段时间还存活着，则被移动到 Old 区。（其实还有一个 Perm 区，但是内存回收算法通常不涉及这个区域）<br>Young 区和 Old 区因为对象的特点不一样，所以采用了两种完全不同的内存回收算法。<br>Young 区的对象因为大部分生命期都很短，每次回收之后只有少部分能够存活，所以采用的算法叫 Copying 算法，简单说来就是直接把活着的对象复制到另一个地方。Young 区内部又分成了三块区域：Eden 区 , From 区 , To 区。每次执行 Copying 算法时，即将存活的对象从 Eden 区和 From 区复制到 To 区，然后交换 From 区和 To 区的名字（即 From 区变成 To 区，To 区变成 From 区）。<br>Old 区的对象因为都是存活下来的老司机了，所以如果用 Copying 算法的话，很可能 90% 的对象都得复制一遍了，不划算啊！所以 Old 区的回收算法叫 Mark-Sweep 算法。简单来说，就是只是把不用的对象先标记（Mark）出来，然后回收（Sweep），活着的对象就不动它了。因为大部分对象都活着，所以回收下来的对象并不多。但是这个算法会有一个问题：它会产生内存碎片，所以它一般还会带有整理内存碎片的逻辑，在算法中叫做 Compact。如何整理呢？早年用过 Windows 的硬盘碎片整理程序的朋友可能能理解，其实就是把对象插到这些空的位置里。这里面还涉及很多优化的细节，我就不一一展开了。<br>讲完主要的算法，接下来 GC 需要解决的问题就只剩下如何找出需要回收的垃圾对象了。为了避免 ARC 解决不了的循环引用问题，GC 引入了一个叫做「可达性」的概念，应用这个概念，即使是有循环引用的垃圾对象，也可以被回收掉。下面就给大家介绍一下这个概念。<br>当 GC 工作时，GC 认为当前的一些对象是有效的，这些对象包括：全局变量，栈里面的变量等，然后 GC 从这些变量出发，去标记这些变量「可达」的其它变量，这个标记是一个递归的过程，最后就像从树根的内存对象开始，把所有的树枝和树叶都记成可达的了。那除了这些「可达」的变量，别的变量就都需要被回收了。<br>听起来很牛逼对不对？那为什么苹果不用呢？实际上苹果在 OS X 10.5 的时候还真用了，不过在 10.7 的时候把 GC 换成了 ARC。那么，GC 有什么问题让苹果不能忍，这就是：垃圾回收的时候，整个程序需要暂停，英文把这个过程叫做：Stop the World。所以说，你知道 Android 手机有时候为什么会卡吧，GC 就相当于春运的最后一天返城高峰。当所有的对象都需要一起回收时，那种体验肯定是当时还在世的乔布斯忍受不了的。<br>看看下面这幅漫画，真实地展现出 GC 最尴尬的情况（漫画中提到的 Full GC，就是指执行 Old 区的内存回收）：</p>
<p>当然，事实上经过多年的发展，GC 的回收算法一直在被优化，人们想了各种办法来优化暂停的时间，所以情况并没有那么糟糕。</p>
<p>答案</p>
<p>ARC 相对于 GC 的优点：</p>
<ol>
<li>ARC 工作在编译期，在运行时没有额外开销。</li>
<li>ARC 的内存回收是平稳进行的，对象不被使用时会立即被回收。而 GC 的内存回收是一阵一阵的，回收时需要暂停程序，会有一定的卡顿。</li>
</ol>
<p>ARC 相对于 GC 的缺点：</p>
<ol>
<li>GC 真的是太简单了，基本上完全不用处理内存管理问题，而 ARC 还是需要处理类似循环引用这种内存管理问题。</li>
<li>GC 一类的语言相对来说学习起来更简单。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h3&gt;&lt;p&gt;我们知道，Android 手机通常使用 Java 来开发，而 Java 是使用垃圾回收这种内存管理方式。 那么，ARC 和垃圾回收对比，有什
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://MelodyZhy.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS11适配之导航栏的titleView如何处理</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/iOS11%E9%80%82%E9%85%8D%E4%B9%8B%E5%AF%BC%E8%88%AA%E6%A0%8F%E7%9A%84titleView%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/iOS11适配之导航栏的titleView如何处理/</id>
    <published>2018-03-22T07:07:33.000Z</published>
    <updated>2018-03-22T07:07:58.060Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface CCNavigationTitleView : UIView</div><div class="line">@property(nonatomic, assign) CGSize intrinsicContentSize;</div><div class="line">@end</div><div class="line"> </div><div class="line">@implementation CCNavigationTitleView</div><div class="line">@end</div><div class="line"></div><div class="line"> CCNavigationTitleView *titleView = [[CCNavigationTitleView alloc] init];</div><div class="line"> titleView.frame = CGRectMake(0, 0, [MMUIUtility screenWidth], 44);</div><div class="line"> titleView.backgroundColor = [UIColor clearColor];</div><div class="line"> titleView.intrinsicContentSize = CGSizeMake([MMUIUtility screenWidth], 44);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://MelodyZhy.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS开发之hitTest:withEvent方法的使用</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/iOS%E5%BC%80%E5%8F%91%E4%B9%8BhitTest-withEvent%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/iOS开发之hitTest-withEvent方法的使用/</id>
    <published>2018-03-22T07:01:34.000Z</published>
    <updated>2018-03-22T07:06:27.551Z</updated>
    
    <content type="html"><![CDATA[<h4 id="首先看下点击事件的传递过程，以及最终是怎么确定到底是点击了哪个视图的"><a href="#首先看下点击事件的传递过程，以及最终是怎么确定到底是点击了哪个视图的" class="headerlink" title="首先看下点击事件的传递过程，以及最终是怎么确定到底是点击了哪个视图的"></a>首先看下点击事件的传递过程，以及最终是怎么确定到底是点击了哪个视图的</h4><p><img src="/images/226702-dd53b5a6df2f3ea5.png" alt=""></p>
<h4 id="hitTest-withEvent-方法的处理流程"><a href="#hitTest-withEvent-方法的处理流程" class="headerlink" title="hitTest:withEvent:方法的处理流程:"></a>hitTest:withEvent:方法的处理流程:</h4><h5 id="一、先调用pointInside-withEvent-判断触摸点是否在当前视图内"><a href="#一、先调用pointInside-withEvent-判断触摸点是否在当前视图内" class="headerlink" title="一、先调用pointInside:withEvent:判断触摸点是否在当前视图内"></a>一、先调用pointInside:withEvent:判断触摸点是否在当前视图内</h5><p> 1.如果返回YES，那么该视图的所有子视图调用hitTest:withEvent,调用顺序由层级低到高（top-&gt;bottom）依次调用。</p>
<p> 2.如果返回NO，那么hitTest:withEvent返回nil，该视图的所有子视图的分支全部被忽略</p>
<h4 id="二、如果某视图的pointInside-withEvent-返回YES，并且他的所有子视图hitTest-withEvent-都返回nil，或者该视图没有子视图，那么该视图的hitTest-withEvent-返回自己。"><a href="#二、如果某视图的pointInside-withEvent-返回YES，并且他的所有子视图hitTest-withEvent-都返回nil，或者该视图没有子视图，那么该视图的hitTest-withEvent-返回自己。" class="headerlink" title="二、如果某视图的pointInside:withEvent:返回YES，并且他的所有子视图hitTest:withEvent:都返回nil，或者该视图没有子视图，那么该视图的hitTest:withEvent:返回自己。"></a>二、如果某视图的pointInside:withEvent:返回YES，并且他的所有子视图hitTest:withEvent:都返回nil，或者该视图没有子视图，那么该视图的hitTest:withEvent:返回自己。</h4><h4 id="三、如果子视图的hitTest-withEvent-返回非空对象，那么当前视图的hitTest-withEvent-也返回这个对象，也就是沿原路回推，最终将hit-test-view传递给keyWindow"><a href="#三、如果子视图的hitTest-withEvent-返回非空对象，那么当前视图的hitTest-withEvent-也返回这个对象，也就是沿原路回推，最终将hit-test-view传递给keyWindow" class="headerlink" title="三、如果子视图的hitTest:withEvent:返回非空对象，那么当前视图的hitTest:withEvent:也返回这个对象，也就是沿原路回推，最终将hit-test view传递给keyWindow"></a>三、如果子视图的hitTest:withEvent:返回非空对象，那么当前视图的hitTest:withEvent:也返回这个对象，也就是沿原路回推，最终将hit-test view传递给keyWindow</h4><h4 id="四、以下视图的hitTest-withEvent-方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件："><a href="#四、以下视图的hitTest-withEvent-方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件：" class="headerlink" title="四、以下视图的hitTest:withEvent:方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件："></a>四、以下视图的hitTest:withEvent:方法会返回nil，导致自身和其所有子视图不能被hit-testing发现，无法响应触摸事件：</h4><p> 1.隐藏(hidden=YES)的视图</p>
<p> 2.禁止用户操作(userInteractionEnabled=NO)的视图</p>
<p> 3.alpha&lt;0.01的视图</p>
<p> 4.视图超出父视图的区域</p>
<h5 id="既然我们知道了hitTest的处理流程那么我们就可以改变事件的响应链来达到我们的各种目的"><a href="#既然我们知道了hitTest的处理流程那么我们就可以改变事件的响应链来达到我们的各种目的" class="headerlink" title="既然我们知道了hitTest的处理流程那么我们就可以改变事件的响应链来达到我们的各种目的"></a>既然我们知道了hitTest的处理流程那么我们就可以改变事件的响应链来达到我们的各种目的</h5><h4 id="一、强制指定某视图响应触摸事件"><a href="#一、强制指定某视图响应触摸事件" class="headerlink" title="一、强制指定某视图响应触摸事件"></a>一、强制指定某视图响应触摸事件</h4><p>将截获的对象替换成指定的对象、也就说如果一个视图设置了无法触发事件其实也是可以响应的，但button设置了userInteractionEnabled=NO或者enable＝NO是无法响应的</p>
<h4 id="二、忽略指定的视图"><a href="#二、忽略指定的视图" class="headerlink" title="二、忽略指定的视图"></a>二、忽略指定的视图</h4><p>在hitTest:withEvent:里筛选返回值，针对指定的对象返回nil （这样做的好处是不会阻断hit－testing检测，既可忽略指定的视图又不会屏蔽其子视图）</p>
<h4 id="三、超出父视图范围响应"><a href="#三、超出父视图范围响应" class="headerlink" title="三、超出父视图范围响应"></a>三、超出父视图范围响应</h4><p>选定一个节点，遍历他的所有子节点用pointInside:withEvent:判断是否命中，直到找到命中的最低层级的视图，此时我们已经抛弃了系统的hit-testing规则。</p>
<h4 id="hitTest-withEvent-方法的底层实现"><a href="#hitTest-withEvent-方法的底层实现" class="headerlink" title="hitTest: withEvent:方法的底层实现"></a>hitTest: withEvent:方法的底层实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// 因为所有的视图类都是继承BaseView</div><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</div><div class="line">    // 1.判断当前控件能否接收事件</div><div class="line">    if (self.userInteractionEnabled == NO || self.hidden == YES || self.alpha &lt;= 0.01) return nil;</div><div class="line">    </div><div class="line">    // 2. 判断点在不在当前控件</div><div class="line">    if ([self pointInside:point withEvent:event] == NO) return nil;</div><div class="line">    </div><div class="line">    // 3.从后往前遍历自己的子控件</div><div class="line">    NSInteger count = self.subviews.count;</div><div class="line">    </div><div class="line">    for (NSInteger i = count - 1; i &gt;= 0; i--) &#123;</div><div class="line">        UIView *childView = self.subviews[i];</div><div class="line">        </div><div class="line">        // 把当前控件上的坐标系转换成子控件上的坐标系</div><div class="line">        CGPoint childP = [self convertPoint:point toView:childView];</div><div class="line">        </div><div class="line">        UIView *fitView = [childView hitTest:childP withEvent:event];</div><div class="line">        </div><div class="line">        </div><div class="line">        if (fitView) &#123; // 寻找到最合适的view</div><div class="line">            return fitView;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 循环结束,表示没有比自己更合适的view</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;首先看下点击事件的传递过程，以及最终是怎么确定到底是点击了哪个视图的&quot;&gt;&lt;a href=&quot;#首先看下点击事件的传递过程，以及最终是怎么确定到底是点击了哪个视图的&quot; class=&quot;headerlink&quot; title=&quot;首先看下点击事件的传递过程，以及最终是怎么确定到
    
    </summary>
    
    
      <category term="iOS开发" scheme="http://MelodyZhy.github.io/tags/iOS%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>终端使用输入小技巧</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8%E8%BE%93%E5%85%A5%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/终端使用输入小技巧/</id>
    <published>2018-03-22T07:00:38.000Z</published>
    <updated>2018-03-22T07:01:13.409Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CTRL-U-剪切光标前的内容"><a href="#CTRL-U-剪切光标前的内容" class="headerlink" title="CTRL + U - 剪切光标前的内容"></a>CTRL + U - 剪切光标前的内容</h3><h3 id="CTRL-K-剪切光标至行末的内容"><a href="#CTRL-K-剪切光标至行末的内容" class="headerlink" title="CTRL + K - 剪切光标至行末的内容"></a>CTRL + K - 剪切光标至行末的内容</h3><h3 id="CTRL-Y-粘贴"><a href="#CTRL-Y-粘贴" class="headerlink" title="CTRL + Y - 粘贴"></a>CTRL + Y - 粘贴</h3><h3 id="CTRL-E-移动光标到行末"><a href="#CTRL-E-移动光标到行末" class="headerlink" title="CTRL + E - 移动光标到行末"></a>CTRL + E - 移动光标到行末</h3><h3 id="CTRL-A-移动光标到行首"><a href="#CTRL-A-移动光标到行首" class="headerlink" title="CTRL + A - 移动光标到行首"></a>CTRL + A - 移动光标到行首</h3><h3 id="CTRL-B-或左箭头键-左移一个字符（移至前一个字符）"><a href="#CTRL-B-或左箭头键-左移一个字符（移至前一个字符）" class="headerlink" title="CTRL + B  或左箭头键 左移一个字符（移至前一个字符）"></a>CTRL + B  或左箭头键 左移一个字符（移至前一个字符）</h3><h3 id="CTRL-F-或右箭头键-右移一个字符（移至后一个字符）"><a href="#CTRL-F-或右箭头键-右移一个字符（移至后一个字符）" class="headerlink" title="CTRL + F  或右箭头键 右移一个字符（移至后一个字符）"></a>CTRL + F  或右箭头键 右移一个字符（移至后一个字符）</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CTRL-U-剪切光标前的内容&quot;&gt;&lt;a href=&quot;#CTRL-U-剪切光标前的内容&quot; class=&quot;headerlink&quot; title=&quot;CTRL + U - 剪切光标前的内容&quot;&gt;&lt;/a&gt;CTRL + U - 剪切光标前的内容&lt;/h3&gt;&lt;h3 id=&quot;CTRL-
    
    </summary>
    
    
      <category term="Mac" scheme="http://MelodyZhy.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>如何给一个视图添加一个或多个圆角</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/%E5%A6%82%E4%BD%95%E7%BB%99%E4%B8%80%E4%B8%AA%E8%A7%86%E5%9B%BE%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%9C%86%E8%A7%92/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/如何给一个视图添加一个或多个圆角/</id>
    <published>2018-03-22T06:57:13.000Z</published>
    <updated>2018-03-22T07:00:01.452Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/屏幕快照 2017-06-23 13.42.18.png" alt=""></p>
<p>如果我们想做这样的视图，那么就需要用到这两个类</p>
<p>UIBezierPath</p>
<p>CAShapeLayer</p>
<p>这个枚举</p>
<p>UIRectCorner</p>
<p>以及这个方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (instancetype)bezierPathWithRoundedRect:(CGRect)rect byRoundingCorners:(UIRectCorner)corners cornerRadii:(CGSize)cornerRadii;</div></pre></td></tr></table></figure>
<h4 id="下面介绍下这个类CCRectCorner"><a href="#下面介绍下这个类CCRectCorner" class="headerlink" title="下面介绍下这个类CCRectCorner"></a>下面介绍下这个类CCRectCorner</h4><p><img src="/images/屏幕快照 2017-06-23 13.46.39.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/images/屏幕快照 2017-06-23 13.42.18.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果我们想做这样的视图，那么就需要用到这两个类&lt;/p&gt;
&lt;p&gt;UIBezierPath&lt;/p&gt;
&lt;p&gt;CAShapeLayer&lt;/p&gt;
&lt;p&gt;这个枚
    
    </summary>
    
    
      <category term="UI" scheme="http://MelodyZhy.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>NSCalendar的介绍及使用</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/NSCalendar%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/NSCalendar的介绍及使用/</id>
    <published>2018-03-22T06:48:39.000Z</published>
    <updated>2018-03-22T06:56:11.683Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先先来解释一波名词-（公历、阳历、农历、阴历、历法）"><a href="#首先先来解释一波名词-（公历、阳历、农历、阴历、历法）" class="headerlink" title="首先先来解释一波名词 （公历、阳历、农历、阴历、历法）"></a>首先先来解释一波名词 （公历、阳历、农历、阴历、历法）</h3><p>公历、阳历是一个意思 就是咱们平时说的今天几号了那个几号了</p>
<p>农历、阴历是一个意思 就是咱们日历上另一个日期（一般比阳历晚一个月左右）</p>
<p>历法是推算年、月、日，并使其与相关天象对应的方法，是协调历年、历月、历日和<a href="http://baike.baidu.com/item/%E5%9B%9E%E5%BD%92%E5%B9%B4" target="_blank" rel="external">回归年</a>、<a href="http://baike.baidu.com/item/%E6%9C%94%E6%9C%9B%E6%9C%88" target="_blank" rel="external">朔望月</a>和<a href="http://baike.baidu.com/item/%E5%A4%AA%E9%98%B3%E6%97%A5" target="_blank" rel="external">太阳日</a>的办法</p>
<h3 id="介绍NSCalendar、NSDate、NSDateComponents"><a href="#介绍NSCalendar、NSDate、NSDateComponents" class="headerlink" title="介绍NSCalendar、NSDate、NSDateComponents"></a>介绍NSCalendar、NSDate、NSDateComponents</h3><p>NSCalendar对世界上现存的常用的历法进行了封装，既提供了不同历法的时间信息，又支持日历的计算。</p>
<p>NSDateFomatter表示的时间默认以公历（即阳历）为参考，可以通过设置calendar属性变量获得特定历法下的时间表示。</p>
<p>NSDate是独立与任何历法的，它只是时间相对于某个时间点的时间差，NSDate是进行日历计算的基础。</p>
<p>NSDateComponents将时间表示成适合人类阅读和使用的方式，通过NSDateComponents可以快速而简单地获取某个时间点对应的“年”，“月”，“日”，“时”，“分”，“秒”，“周”等信息。当然一旦涉及了年月日时分秒就要和某个历法绑定，因此NSDateComponents必须和NSCalendar一起使用，默认为公历。</p>
<p>NSDateComponents除了像上面说的表示一个时间点外，还可以表示时间段，例如：两周，三个月，20年，7天，10分钟，50秒等等。时间段用于日历的计算。</p>
<p>要获取某个时间点在某个历法下的表示，需要NSDateComponents；要计算当前时间点在某个历法下对应的一个时间段前或后的时间点，需要NSDateComponents</p>
<p>NSDateComponents返回的day, week, weekday, month, year这一类数据都是从1开始的</p>
<h3 id="五个Demo演示NSCalendar的常用用法"><a href="#五个Demo演示NSCalendar的常用用法" class="headerlink" title="五个Demo演示NSCalendar的常用用法"></a>五个Demo演示NSCalendar的常用用法</h3><h4 id="1-获取当前时间的年月日时分秒"><a href="#1-获取当前时间的年月日时分秒" class="headerlink" title="1.获取当前时间的年月日时分秒"></a>1.获取当前时间的年月日时分秒</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">// 先定义一个遵循某个历法的日历对象</div><div class="line">NSCalendar *greCalendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</div><div class="line">// 通过已定义的日历对象，获取某个时间点的NSDateComponents表示，并设置需要表示哪些信息（NSYearCalendarUnit, NSMonthCalendarUnit, NSDayCalendarUnit等）</div><div class="line">NSDateComponents *dateComponents = [greCalendar components:NSCalendarUnitYear | NSCalendarUnitQuarter | NSCalendarUnitMonth | NSCalendarUnitDay | NSCalendarUnitHour | NSCalendarUnitMinute | NSCalendarUnitSecond | NSCalendarUnitWeekday | NSCalendarUnitWeekOfMonth | NSCalendarUnitWeekOfYear fromDate:[NSDate date]];</div><div class="line"></div><div class="line">UILabel *dateLabel = [[UILabel alloc] init];</div><div class="line">dateLabel.textColor = [UIColor blackColor];</div><div class="line">dateLabel.font = [UIFont systemFontOfSize:16];</div><div class="line">dateLabel.numberOfLines = 0;</div><div class="line">[self.view addSubview:dateLabel];</div><div class="line"></div><div class="line">NSString *year = [NSString stringWithFormat:@&quot;year(年份): %zd&quot;, dateComponents.year];</div><div class="line">NSString *quarter = [NSString stringWithFormat:@&quot;quarter(季度):%zd&quot;, dateComponents.quarter];</div><div class="line">NSString *month = [NSString stringWithFormat:@&quot;month(月份):%zd&quot;, dateComponents.month];</div><div class="line">NSString *day = [NSString stringWithFormat:@&quot;day(日期):%zd&quot;, dateComponents.day];</div><div class="line">NSString *hour = [NSString stringWithFormat:@&quot;hour(小时):%zd&quot;, dateComponents.hour];</div><div class="line">NSString *minute = [NSString stringWithFormat:@&quot;minute(分钟):%zd&quot;, dateComponents.minute];</div><div class="line">NSString *second = [NSString stringWithFormat:@&quot;second(秒):%zd&quot;, dateComponents.second];</div><div class="line">// Sunday:1, Monday:2, Tuesday:3, Wednesday:4, Friday:5, Saturday:6</div><div class="line">NSString *weekday = [NSString stringWithFormat:@&quot;weekday(星期):%zd&quot;, dateComponents.weekday];</div><div class="line">// 苹果官方不推荐使用week (dateComponents.week)</div><div class="line">// Use weekOfMonth or weekOfYear, depending on which you mean</div><div class="line">NSString *weekOfYear = [NSString stringWithFormat:@&quot;weekOfYear(该年第几周):%zd&quot;, dateComponents.weekOfYear];</div><div class="line">NSString *weekOfMonth = [NSString stringWithFormat:@&quot;weekOfMonth(该月第几周):%zd&quot;, dateComponents.weekOfMonth];</div><div class="line">NSString *dateStr = [NSString stringWithFormat:@&quot;%@\n%@\n%@\n%@\n%@\n%@\n%@\n%@\n%@\n%@&quot;, year, quarter, month, day, hour, minute, second, weekday, weekOfYear, weekOfMonth];</div><div class="line"></div><div class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:dateStr];</div><div class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class="line">[paragraphStyle setLineSpacing:7];</div><div class="line">[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [dateStr length])];</div><div class="line">dateLabel.attributedText = attributedString;</div><div class="line">[dateLabel sizeToFit];</div><div class="line">dateLabel.center = self.view.center;</div></pre></td></tr></table></figure>
<h4 id="2-获取历法中对应的时间点"><a href="#2-获取历法中对应的时间点" class="headerlink" title="2.获取历法中对应的时间点"></a>2.获取历法中对应的时间点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">NSCalendar *greCalendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</div><div class="line"></div><div class="line">NSDateComponents *dateComponents = [[NSDateComponents alloc] init];</div><div class="line">[dateComponents setDay:8];</div><div class="line">[dateComponents setMonth:8];</div><div class="line">[dateComponents setYear:2008];</div><div class="line">[dateComponents setMinute:8];</div><div class="line">[dateComponents setHour:8];</div><div class="line">[dateComponents setSecond:8];</div><div class="line"></div><div class="line">NSDate *date = [greCalendar dateFromComponents:dateComponents];</div><div class="line"></div><div class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</div><div class="line">/// EEE 周五 EEEE 星期五</div><div class="line">dateFormatter.dateFormat = @&quot;yyyy-MM-dd hh:mm:ss EEEE&quot;;</div><div class="line">NSString *dateStr = [dateFormatter stringFromDate:date];</div><div class="line"></div><div class="line">UILabel *dateLabel = [[UILabel alloc] init];</div><div class="line">dateLabel.textColor = [UIColor blackColor];</div><div class="line">dateLabel.font = [UIFont systemFontOfSize:16];</div><div class="line">[self.view addSubview:dateLabel];</div><div class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:dateStr];</div><div class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class="line">[paragraphStyle setLineSpacing:7];</div><div class="line">[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [dateStr length])];</div><div class="line">dateLabel.attributedText = attributedString;</div><div class="line">[dateLabel sizeToFit];</div><div class="line">dateLabel.center = self.view.center;</div></pre></td></tr></table></figure>
<h4 id="3-在当前历法下，获取一段时间后的时间点"><a href="#3-在当前历法下，获取一段时间后的时间点" class="headerlink" title="3.在当前历法下，获取一段时间后的时间点"></a>3.在当前历法下，获取一段时间后的时间点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">NSCalendar *greCalendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</div><div class="line"></div><div class="line">NSDateComponents *dateComponents = [[NSDateComponents alloc] init];</div><div class="line">[dateComponents setDay:6];</div><div class="line">[dateComponents setMonth:3];</div><div class="line">[dateComponents setYear:3];</div><div class="line"></div><div class="line">NSDate *date = [greCalendar dateByAddingComponents:dateComponents toDate:[NSDate date] options:0];</div><div class="line"></div><div class="line">NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init];</div><div class="line">dateFormatter.dateFormat = @&quot;yyyy-MM-dd hh:mm:ss&quot;;</div><div class="line">NSString *dateStr = [dateFormatter stringFromDate:date];</div><div class="line"></div><div class="line">UILabel *dateLabel = [[UILabel alloc] init];</div><div class="line">dateLabel.textColor = [UIColor blackColor];</div><div class="line">dateLabel.font = [UIFont systemFontOfSize:16];</div><div class="line">[self.view addSubview:dateLabel];</div><div class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:dateStr];</div><div class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class="line">[paragraphStyle setLineSpacing:7];</div><div class="line">[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [dateStr length])];</div><div class="line">dateLabel.attributedText = attributedString;</div><div class="line">[dateLabel sizeToFit];</div><div class="line">dateLabel.center = self.view.center;</div></pre></td></tr></table></figure>
<h4 id="4-根据两个时间点-获取这两个时间点的时差"><a href="#4-根据两个时间点-获取这两个时间点的时差" class="headerlink" title="4.根据两个时间点,获取这两个时间点的时差"></a>4.根据两个时间点,获取这两个时间点的时差</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">NSCalendar *greCalendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian];</div><div class="line"></div><div class="line">NSDateComponents *dateComponents = [greCalendar components:NSCalendarUnitYear fromDate:[NSDate dateWithTimeIntervalSince1970:0] toDate:[NSDate date] options:0];</div><div class="line"></div><div class="line">NSString *dateStr = [NSString stringWithFormat:@&quot;1970年距离今年有%zd年了&quot;, dateComponents.year];</div><div class="line"></div><div class="line">UILabel *dateLabel = [[UILabel alloc] init];</div><div class="line">dateLabel.textColor = [UIColor blackColor];</div><div class="line">dateLabel.font = [UIFont systemFontOfSize:16];</div><div class="line">[self.view addSubview:dateLabel];</div><div class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:dateStr];</div><div class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class="line">[paragraphStyle setLineSpacing:7];</div><div class="line">[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [dateStr length])];</div><div class="line">dateLabel.attributedText = attributedString;</div><div class="line">[dateLabel sizeToFit];</div><div class="line">dateLabel.center = self.view.center;</div></pre></td></tr></table></figure>
<h4 id="5-某个时间点所在的“小单元”，在“大单元”中的数量"><a href="#5-某个时间点所在的“小单元”，在“大单元”中的数量" class="headerlink" title="5.某个时间点所在的“小单元”，在“大单元”中的数量"></a>5.某个时间点所在的“小单元”，在“大单元”中的数量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// 当前时间对应的月份中有几天</div><div class="line">NSInteger days = [[NSCalendar currentCalendar] rangeOfUnit:NSCalendarUnitDay inUnit:NSCalendarUnitMonth forDate:[NSDate date]].length;</div><div class="line">// 当前时间对应的月份中有几周</div><div class="line">NSInteger weeks = [[NSCalendar currentCalendar] rangeOfUnit:NSCalendarUnitWeekOfMonth inUnit:NSCalendarUnitMonth forDate:[NSDate date]].length;</div><div class="line"></div><div class="line">NSString *dateStr = [NSString stringWithFormat:@&quot;当前月份有%zd天,%zd周&quot;, days, weeks];</div><div class="line"></div><div class="line">UILabel *dateLabel = [[UILabel alloc] init];</div><div class="line">dateLabel.textColor = [UIColor blackColor];</div><div class="line">dateLabel.font = [UIFont systemFontOfSize:16];</div><div class="line">[self.view addSubview:dateLabel];</div><div class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:dateStr];</div><div class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class="line">[paragraphStyle setLineSpacing:7];</div><div class="line">[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [dateStr length])];</div><div class="line">dateLabel.attributedText = attributedString;</div><div class="line">[dateLabel sizeToFit];</div><div class="line">dateLabel.center = self.view.center;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;首先先来解释一波名词-（公历、阳历、农历、阴历、历法）&quot;&gt;&lt;a href=&quot;#首先先来解释一波名词-（公历、阳历、农历、阴历、历法）&quot; class=&quot;headerlink&quot; title=&quot;首先先来解释一波名词 （公历、阳历、农历、阴历、历法）&quot;&gt;&lt;/a&gt;首先先来解
    
    </summary>
    
    
      <category term="Foundation框架" scheme="http://MelodyZhy.github.io/tags/Foundation%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>iOS手势返回的一些注意点</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/iOS%E6%89%8B%E5%8A%BF%E8%BF%94%E5%9B%9E%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/iOS手势返回的一些注意点/</id>
    <published>2018-03-22T06:39:59.000Z</published>
    <updated>2018-03-22T06:46:44.676Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>当进入能左右滑动的界面，就会造成滑动返回的手势和界面左右滑动的手势冲突，导致不能在屏幕边缘向右滑动退出当前页面。</p>
</blockquote>
<h2 id="有两种效果解决这个问题"><a href="#有两种效果解决这个问题" class="headerlink" title="有两种效果解决这个问题"></a>有两种效果解决这个问题</h2><h3 id="第一种-只有在左右滑动视图的最左面，才执行屏幕边缘滑动退出当前页面"><a href="#第一种-只有在左右滑动视图的最左面，才执行屏幕边缘滑动退出当前页面" class="headerlink" title="第一种 只有在左右滑动视图的最左面，才执行屏幕边缘滑动退出当前页面"></a>第一种 只有在左右滑动视图的最左面，才执行屏幕边缘滑动退出当前页面</h3><h4 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h4><p>iOS系统中，滑动返回手势，其实是一个UIPanGestureRecognizer，系统默认的操作是只有滑动屏幕左边的某个位置，UIPanGestureRecognizer才会起作用。滑动视图的滑动手势也是UIPanGestureRecognizer。</p>
<p>那么解决方案就是在侧边滑动时，让滑动视图不响应事件就可以了，我们可以写一个滚动视图的分类重写它的hitTest方法 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event &#123;</div><div class="line">    if (point.x &lt; 20) &#123;</div><div class="line">        return nil;</div><div class="line">    &#125; else &#123;</div><div class="line">        return [super hitTest:point withEvent:event];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但这样只能是在滑动视图的最左面才能实现滑动退出当前视图，如何真正实现滑动屏幕最左面就能退出当前视图呢 那么我们来看下第二种方法</p>
<h3 id="第二种-滑动屏幕最左面退出当前视图"><a href="#第二种-滑动屏幕最左面退出当前视图" class="headerlink" title="第二种 滑动屏幕最左面退出当前视图"></a>第二种 滑动屏幕最左面退出当前视图</h3><p>使用这个方法 requireGestureRecognizerToFail  （指定一个手势需要另一个手势执行失败才会执行）</p>
<p>有了这个方法就可以让滚动视图的 panGestureRecognizer 在 navigationController 的返回手势 interactivePopGestureRecognizer 执行失败后在执行 懂了吧～</p>
<p>代码例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[collectionView.panGestureRecognizer requireGestureRecognizerToFail:self.navigationController.interactivePopGestureRecognizer];</div></pre></td></tr></table></figure>
<p>引出一个小问题如何改变滑动屏幕左边的距离，来减少滑动返回误操作</p>
<p>我们的navigationController都是统一的一个，这要在这个基类里面遵守 UIGestureRecognizerDelegate 在 gestureRecognizerShouldBegin 方法里面做一些处理代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (BOOL)gestureRecognizerShouldBegin:(UIPanGestureRecognizer *)gestureRecognizer &#123;</div><div class="line">    if (self.childViewControllers.count &gt; 1) &#123;</div><div class="line">        CGPoint beginningLocation = [gestureRecognizer locationInView:gestureRecognizer.view];</div><div class="line">        CGFloat maxAllowedInitialDistance = 18;</div><div class="line">        if (maxAllowedInitialDistance &gt; 0 &amp;&amp; beginningLocation.x &gt; maxAllowedInitialDistance) &#123;</div><div class="line">            return NO;</div><div class="line">        &#125; else &#123;</div><div class="line">            return YES;</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        return NO;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当进入能左右滑动的界面，就会造成滑动返回的手势和界面左右滑动的手势冲突，导致不能在屏幕边缘向右滑动退出当前页面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;有两种效果解决这个问题&quot;&gt;&lt;a href=&quot;#有两种效果解决这个问题&quot; class
    
    </summary>
    
    
      <category term="UI" scheme="http://MelodyZhy.github.io/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>使用Zsh让终端更好用</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/%E4%BD%BF%E7%94%A8Zsh%E8%AE%A9%E7%BB%88%E7%AB%AF%E6%9B%B4%E5%A5%BD%E7%94%A8/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/使用Zsh让终端更好用/</id>
    <published>2018-03-22T06:38:54.000Z</published>
    <updated>2018-03-22T06:39:29.215Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Oh-My-Zsh地址-http-ohmyz-sh"><a href="#Oh-My-Zsh地址-http-ohmyz-sh" class="headerlink" title="Oh My Zsh地址    http://ohmyz.sh"></a>Oh My Zsh地址    <a href="http://ohmyz.sh/" target="_blank" rel="external">http://ohmyz.sh</a></h1><h3 id="使用alias-简化命令"><a href="#使用alias-简化命令" class="headerlink" title="使用alias 简化命令"></a>使用alias 简化命令</h3><h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><h4 id="alias-ohmyzsh-”vi-zshrc”"><a href="#alias-ohmyzsh-”vi-zshrc”" class="headerlink" title="alias ohmyzsh=”vi ~/.zshrc”"></a>alias ohmyzsh=”vi ~/.zshrc”</h4><h4 id="alias-cmm-”cd-Users-Melody-Zhy-Downloads-Job-ManagerIOS”"><a href="#alias-cmm-”cd-Users-Melody-Zhy-Downloads-Job-ManagerIOS”" class="headerlink" title="alias cmm=”cd /Users/Melody_Zhy/Downloads/Job/ManagerIOS”"></a>alias cmm=”cd /Users/Melody_Zhy/Downloads/Job/ManagerIOS”</h4><h4 id="alias-driver-”cd-Users-Melody-Zhy-Downloads-Job-Driver”"><a href="#alias-driver-”cd-Users-Melody-Zhy-Downloads-Job-Driver”" class="headerlink" title="alias driver=”cd /Users/Melody_Zhy/Downloads/Job/Driver”"></a>alias driver=”cd /Users/Melody_Zhy/Downloads/Job/Driver”</h4><h4 id="alias-shipper-”cd-Users-Melody-Zhy-Downloads-Job-shipper-ios”"><a href="#alias-shipper-”cd-Users-Melody-Zhy-Downloads-Job-shipper-ios”" class="headerlink" title="alias shipper=”cd /Users/Melody_Zhy/Downloads/Job/shipper_ios”"></a>alias shipper=”cd /Users/Melody_Zhy/Downloads/Job/shipper_ios”</h4><h3 id="更换主题"><a href="#更换主题" class="headerlink" title="更换主题"></a>更换主题</h3><h4 id="ZSH-THEME-”candy”"><a href="#ZSH-THEME-”candy”" class="headerlink" title="ZSH_THEME=”candy”"></a>ZSH_THEME=”candy”</h4>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Oh-My-Zsh地址-http-ohmyz-sh&quot;&gt;&lt;a href=&quot;#Oh-My-Zsh地址-http-ohmyz-sh&quot; class=&quot;headerlink&quot; title=&quot;Oh My Zsh地址    http://ohmyz.sh&quot;&gt;&lt;/a&gt;Oh My 
    
    </summary>
    
    
      <category term="Mac" scheme="http://MelodyZhy.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>NSAttributeString都能展示什么样的文字</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/NSAttributeString%E9%83%BD%E8%83%BD%E5%B1%95%E7%A4%BA%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E6%96%87%E5%AD%97/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/NSAttributeString都能展示什么样的文字/</id>
    <published>2018-03-22T06:32:19.000Z</published>
    <updated>2018-03-22T06:38:34.899Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">/************************ Attributes ************************/</div><div class="line">// Predefined character attributes for text. If the key is not in the dictionary, then use the default values as described below.</div><div class="line">// 字体 - 默认字体：Helvetica(Neue)，字号：12</div><div class="line">UIKIT_EXTERN NSString * const NSFontAttributeName NS_AVAILABLE(10_0, 6_0);                // UIFont, default Helvetica(Neue) 12</div><div class="line">// 段落 - 文本段落排版格式，行间距...</div><div class="line">UIKIT_EXTERN NSString * const NSParagraphStyleAttributeName NS_AVAILABLE(10_0, 6_0);      // NSParagraphStyle, default defaultParagraphStyle</div><div class="line">// 字体颜色 - 默认为黑色</div><div class="line">UIKIT_EXTERN NSString * const NSForegroundColorAttributeName NS_AVAILABLE(10_0, 6_0);     // UIColor, default blackColor</div><div class="line">// 字体背景颜色 - 默认为无背景色，看起来是透明色</div><div class="line">UIKIT_EXTERN NSString * const NSBackgroundColorAttributeName NS_AVAILABLE(10_0, 6_0);     // UIColor, default nil: no background</div><div class="line">// 连体字符 - 该属性所对应的值是一个 NSNumber 对象(整数)。连体字符是指某些连在一起的字符，它们采用单个的图元符号。0 表示没有连体字符。1 表示使用默认的连体字符。2表示使用所有连体符号。默认值为 1（注意，iOS 不支持值为 2）。</div><div class="line">UIKIT_EXTERN NSString * const NSLigatureAttributeName NS_AVAILABLE(10_0, 6_0);            // NSNumber containing integer, default 1: default ligatures, 0: no ligatures</div><div class="line">// 字间距 - 该属性所对应的值是一个 NSNumber 对象(整数)。字母紧排指定了用于调整字距的像素点数。字母紧排的效果依赖于字体。值为 0 表示不使用字母紧排。默认值为0。</div><div class="line">UIKIT_EXTERN NSString * const NSKernAttributeName NS_AVAILABLE(10_0, 6_0);                // NSNumber containing floating point value, in points; amount to modify default kerning. 0 means kerning is disabled.</div><div class="line">//  删除线 - 取值为 NSNumber 对象（整数）</div><div class="line">UIKIT_EXTERN NSString * const NSStrikethroughStyleAttributeName NS_AVAILABLE(10_0, 6_0);  // NSNumber containing integer, default 0: no strikethrough</div><div class="line">// 下划线 - 取值为 NSNumber 对象（整数），枚举常量 NSUnderlineStyle 中的值，与删除线类似</div><div class="line">UIKIT_EXTERN NSString * const NSUnderlineStyleAttributeName NS_AVAILABLE(10_0, 6_0);      // NSNumber containing integer, default 0: no underline</div><div class="line">// 填充部分颜色 - 不是字体颜色，取值为 UIColor 对象</div><div class="line">UIKIT_EXTERN NSString * const NSStrokeColorAttributeName NS_AVAILABLE(10_0, 6_0);         // UIColor, default nil: same as foreground color</div><div class="line">// 笔画宽度(粗细) - 取值为 NSNumber 对象（整数），负值填充效果，正值中空效果</div><div class="line">UIKIT_EXTERN NSString * const NSStrokeWidthAttributeName NS_AVAILABLE(10_0, 6_0);         // NSNumber containing floating point value, in percent of font point size, default 0: no stroke; positive for stroke alone, negative for stroke and fill (a typical value for outlined text would be 3.0)</div><div class="line">// 阴影属性 - 取值为 NSShadow 对象</div><div class="line">UIKIT_EXTERN NSString * const NSShadowAttributeName NS_AVAILABLE(10_0, 6_0);              // NSShadow, default nil: no shadow</div><div class="line">// 文本特殊效果 - 取值为 NSString 对象，目前只有图版印刷效果可用</div><div class="line">UIKIT_EXTERN NSString *const NSTextEffectAttributeName NS_AVAILABLE(10_10, 7_0);          // NSString, default nil: no text effect</div><div class="line">// 文本附件 - 取值为 NSTextAttachment 对象，常用于文字图片混排</div><div class="line">UIKIT_EXTERN NSString * const NSAttachmentAttributeName NS_AVAILABLE(10_0, 7_0);          // NSTextAttachment, default nil</div><div class="line">// 链接属性 - 点击后调用浏览器打开指定URL地址</div><div class="line">UIKIT_EXTERN NSString * const NSLinkAttributeName NS_AVAILABLE(10_0, 7_0);                // NSURL (preferred) or NSString</div><div class="line">// 基线偏移值 - 取值为 NSNumber (float)，正值上偏，负值下偏</div><div class="line">UIKIT_EXTERN NSString * const NSBaselineOffsetAttributeName NS_AVAILABLE(10_0, 7_0);      // NSNumber containing floating point value, in points; offset from baseline, default 0</div><div class="line">// 下划线颜色 - 默认为黑色</div><div class="line">UIKIT_EXTERN NSString * const NSUnderlineColorAttributeName NS_AVAILABLE(10_0, 7_0);      // UIColor, default nil: same as foreground color</div><div class="line">// 删除线颜色 - 默认为黑色 </div><div class="line">UIKIT_EXTERN NSString * const NSStrikethroughColorAttributeName NS_AVAILABLE(10_0, 7_0);  // UIColor, default nil: same as foreground color</div><div class="line">// 字形倾斜度 - 取值为 NSNumber (float)，正值右倾，负值左倾</div><div class="line">UIKIT_EXTERN NSString * const NSObliquenessAttributeName NS_AVAILABLE(10_0, 7_0);         // NSNumber containing floating point value; skew to be applied to glyphs, default 0: no skew</div><div class="line">// 文本横向拉伸属性 - 取值为 NSNumber (float)，正值横向拉伸文本，负值横向压缩文本</div><div class="line">UIKIT_EXTERN NSString * const NSExpansionAttributeName NS_AVAILABLE(10_0, 7_0);           // NSNumber containing floating point value; log of expansion factor to be applied to glyphs, default 0: no expansion</div><div class="line">// 文字书写方向 - 从左向右书写或者从右向左书写</div><div class="line">UIKIT_EXTERN NSString * const NSWritingDirectionAttributeName NS_AVAILABLE(10_6, 7_0);    // NSArray of NSNumbers representing the nested levels of writing direction overrides as defined by Unicode LRE, RLE, LRO, and RLO characters.  The control characters can be obtained by masking NSWritingDirection and NSWritingDirectionFormatType values.  LRE: NSWritingDirectionLeftToRight|NSWritingDirectionEmbedding, RLE: NSWritingDirectionRightToLeft|NSWritingDirectionEmbedding, LRO: NSWritingDirectionLeftToRight|NSWritingDirectionOverride, RLO: NSWritingDirectionRightToLeft|NSWritingDirectionOverride,</div><div class="line">// 文字排版方向 - 取值为 NSNumber 对象(整数)，0 表示横排文本，1 表示竖排文本</div><div class="line">UIKIT_EXTERN NSString * const NSVerticalGlyphFormAttributeName NS_AVAILABLE(10_7, 6_0);   // An NSNumber containing an integer value.  0 means horizontal text.  1 indicates vertical text.  If not specified, it could follow higher-level vertical orientation settings.  Currently on iOS, it&apos;s always horizontal.  The behavior for any other value is undefined.</div></pre></td></tr></table></figure>
<h1 id="实战用例"><a href="#实战用例" class="headerlink" title="实战用例"></a>实战用例</h1><p><img src="/images/屏幕快照 2017-05-12 14.02.08.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">NSMutableAttributedString *str = [[NSMutableAttributedString alloc] initWithString:@&quot;6.022*1023&quot; attributes:@&#123;NSFontAttributeName : [UIFont systemFontOfSize:16]&#125;];</div><div class="line">[str setAttributes:@&#123;NSFontAttributeName : [UIFont systemFontOfSize:10], NSBaselineOffsetAttributeName : @10&#125; range:NSMakeRange(8, 2)];</div><div class="line">self.showLabel.attributedText = str;</div></pre></td></tr></table></figure>
<p><img src="/images/屏幕快照 2017-05-12 14.04.22.png" alt=""></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:self.infoLabel.text];</div><div class="line">NSMutableParagraphStyle *paragraphStyle = [[NSMutableParagraphStyle alloc] init];</div><div class="line">[paragraphStyle setLineSpacing:7];//调整行间距</div><div class="line">[attributedString addAttribute:NSParagraphStyleAttributeName value:paragraphStyle range:NSMakeRange(0, [self.infoLabel.text length])];</div><div class="line">self.infoLabel.attributedText = attributedString;</div><div class="line">[self.infoLabel sizeToFit];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/di
    
    </summary>
    
    
      <category term="Foundation框架" scheme="http://MelodyZhy.github.io/tags/Foundation%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Mac电脑锁屏小技巧</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/Mac%E7%94%B5%E8%84%91%E9%94%81%E5%B1%8F%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/Mac电脑锁屏小技巧/</id>
    <published>2018-03-22T06:30:19.000Z</published>
    <updated>2018-03-22T06:30:52.426Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一步，找到“系统偏好设置”下的“安全性与隐私”，在“通用”页里勾上“进入睡眠或开始屏幕保护程序后立即要求输入密码”。"><a href="#第一步，找到“系统偏好设置”下的“安全性与隐私”，在“通用”页里勾上“进入睡眠或开始屏幕保护程序后立即要求输入密码”。" class="headerlink" title="第一步，找到“系统偏好设置”下的“安全性与隐私”，在“通用”页里勾上“进入睡眠或开始屏幕保护程序后立即要求输入密码”。"></a>第一步，找到“系统偏好设置”下的“安全性与隐私”，在“通用”页里勾上“进入睡眠或开始屏幕保护程序后立即要求输入密码”。</h3><h3 id="第二步，要用快捷键启动屏幕保护程序，相对复杂一点。在“应用程序”里找到“Automator”。新建一个服务，在“操作”下的“实用工具”里找-到“启动屏幕保护程序”，并把此操作拖动到右边，并且选择“没有输入”和位于“任何应用程序”，保存。"><a href="#第二步，要用快捷键启动屏幕保护程序，相对复杂一点。在“应用程序”里找到“Automator”。新建一个服务，在“操作”下的“实用工具”里找-到“启动屏幕保护程序”，并把此操作拖动到右边，并且选择“没有输入”和位于“任何应用程序”，保存。" class="headerlink" title="第二步，要用快捷键启动屏幕保护程序，相对复杂一点。在“应用程序”里找到“Automator”。新建一个服务，在“操作”下的“实用工具”里找 到“启动屏幕保护程序”，并把此操作拖动到右边，并且选择“没有输入”和位于“任何应用程序”，保存。"></a>第二步，要用快捷键启动屏幕保护程序，相对复杂一点。在“应用程序”里找到“Automator”。新建一个服务，在“操作”下的“实用工具”里找 到“启动屏幕保护程序”，并把此操作拖动到右边，并且选择“没有输入”和位于“任何应用程序”，保存。</h3><h3 id="最后，在“系统偏好设置”里找到“键盘”，然后为刚才定义的服务配置快捷键，我设成了Command-Control-L"><a href="#最后，在“系统偏好设置”里找到“键盘”，然后为刚才定义的服务配置快捷键，我设成了Command-Control-L" class="headerlink" title="最后，在“系统偏好设置”里找到“键盘”，然后为刚才定义的服务配置快捷键，我设成了Command+Control+L"></a>最后，在“系统偏好设置”里找到“键盘”，然后为刚才定义的服务配置快捷键，我设成了Command+Control+L</h3>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;第一步，找到“系统偏好设置”下的“安全性与隐私”，在“通用”页里勾上“进入睡眠或开始屏幕保护程序后立即要求输入密码”。&quot;&gt;&lt;a href=&quot;#第一步，找到“系统偏好设置”下的“安全性与隐私”，在“通用”页里勾上“进入睡眠或开始屏幕保护程序后立即要求输入密码”。&quot; 
    
    </summary>
    
    
      <category term="Mac" scheme="http://MelodyZhy.github.io/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>如何优雅的封装控件&amp;视觉动画</title>
    <link href="http://MelodyZhy.github.io/2018/03/22/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%B0%81%E8%A3%85%E6%8E%A7%E4%BB%B6-%E8%A7%86%E8%A7%89%E5%8A%A8%E7%94%BB/"/>
    <id>http://MelodyZhy.github.io/2018/03/22/如何优雅的封装控件-视觉动画/</id>
    <published>2018-03-22T06:16:35.000Z</published>
    <updated>2018-03-22T06:48:03.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="首先要封装一个控件应该明确以下几点"><a href="#首先要封装一个控件应该明确以下几点" class="headerlink" title="首先要封装一个控件应该明确以下几点"></a>首先要封装一个控件应该明确以下几点</h3><ol>
<li><h5 id="这个控件要做什么"><a href="#这个控件要做什么" class="headerlink" title="这个控件要做什么"></a>这个控件要做什么</h5></li>
<li><h5 id="这个控件至少需要知道哪些信息"><a href="#这个控件至少需要知道哪些信息" class="headerlink" title="这个控件至少需要知道哪些信息"></a>这个控件至少需要知道哪些信息</h5></li>
<li><h5 id="这个控件需要反馈什么信息"><a href="#这个控件需要反馈什么信息" class="headerlink" title="这个控件需要反馈什么信息"></a>这个控件需要反馈什么信息</h5></li>
</ol>
<h3 id="这个控件要做什么-1"><a href="#这个控件要做什么-1" class="headerlink" title="这个控件要做什么"></a>这个控件要做什么</h3><p>​        这个毋庸置疑，需要明确这个控件是做什么的，找出这一类控件的共性，能否写成统一的控件，保持控件的清洁性</p>
<h3 id="这个控件至少需要知道哪些信息-1"><a href="#这个控件至少需要知道哪些信息-1" class="headerlink" title="这个控件至少需要知道哪些信息"></a>这个控件至少需要知道哪些信息</h3><p>​        明确这个控件都需要知道哪些参数，哪些参数是可以通过另外的参数计算来获得，从而减少传入的参数。初始化控件的方法尽量把需要的参数一起传入，让使用的地方简洁明良</p>
<h3 id="这个控件需要反馈什么信息-1"><a href="#这个控件需要反馈什么信息-1" class="headerlink" title="这个控件需要反馈什么信息"></a>这个控件需要反馈什么信息</h3><p>​        反馈使用者区分不同情况的信息</p>
<h3 id="封装控件我们主要封装什么？"><a href="#封装控件我们主要封装什么？" class="headerlink" title="封装控件我们主要封装什么？"></a>封装控件我们主要封装什么？</h3><p>​        主要封装应该为交互方式、显示样式、数据使用</p>
<h3 id="封装的控件应该具有的特性"><a href="#封装的控件应该具有的特性" class="headerlink" title="封装的控件应该具有的特性"></a>封装的控件应该具有的特性</h3><p>​        灵活性、低耦合、易扩展、易维护</p>
<p>​        通常特征之间需要做一些取舍，比如灵活性与耦合度，有时候接口越多越能适应各种环境，但是接口越少对外产生的依赖就越少，维护起来也更容易。通常一些前期看起来还不错的代码，往往也会随着时间加深慢慢“成长”，功能的增加也会带来新的接口，很不自觉地就加深了耦合度，在开发中时不时地进行一些重构工作很有必要。总之，尽量减少接口的数量，但有足够的定制空间，可以在一开始把接口全部隐藏起来，再根据实际需要慢慢放开。</p>
<h3 id="初始化控件方法可以添加些错误断点提示"><a href="#初始化控件方法可以添加些错误断点提示" class="headerlink" title="初始化控件方法可以添加些错误断点提示"></a>初始化控件方法可以添加些错误断点提示</h3><p>​        当使用者初始化错误时进行提示</p>
<p><img src="/images/屏幕快照 2017-05-05 08.37.55.png" alt=""></p>
<h3 id="尽量减少使用时编写的代码"><a href="#尽量减少使用时编写的代码" class="headerlink" title="尽量减少使用时编写的代码"></a>尽量减少使用时编写的代码</h3><p>​        使用宏定义来设置控件的属性，当不同地方需要不同控件属性时建议使用枚举来完成</p>
<p><img src="/images/屏幕快照 2017-05-05 08.42.44.png" alt=""></p>
<h3 id="代码规范问题"><a href="#代码规范问题" class="headerlink" title="代码规范问题"></a>代码规范问题</h3><p><img src="/images/屏幕快照 2017-05-05 08.45.31.png" alt=""></p>
<p><img src="/images/屏幕快照 2017-05-05 08.51.44.png" alt=""></p>
<h2 id="视觉动画"><a href="#视觉动画" class="headerlink" title="视觉动画"></a>视觉动画</h2><p>这种视觉动画就是巧用视图层以及视图覆盖剪切的位移动画</p>
<p><img src="/images/屏幕快照 2017-05-05 11.59.32.png" alt=""></p>
<p>首先创建最底层的Label</p>
<p>然后创建用于位移动画的两个View</p>
<p>第一个View的宽度等于Label的宽度，设置背景颜色且设置clipsToBounds属性为YES（如果子视图的范围超出了父视图的边界，那么超出的部分就会被裁剪掉）</p>
<p>第二个View为承载选中状态Label的View，它的宽度为控件的宽度，添加所有Label到此View上，最后将这个View添加到第一个View上</p>
<p>最后添加最上层的按钮，按钮的frame等于对应Label的frame</p>
<p>执行位移动画时让第一个View移动到点击对应按钮的位置，让第二个View移动的距离为第一个View移动横向距离的负数，就做好了这个视觉动画</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;首先要封装一个控件应该明确以下几点&quot;&gt;&lt;a href=&quot;#首先要封装一个控件应该明确以下几点&quot; class=&quot;headerlink&quot; title=&quot;首先要封装一个控件应该明确以下几点&quot;&gt;&lt;/a&gt;首先要封装一个控件应该明确以下几点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;h5 
    
    </summary>
    
    
      <category term="UI" scheme="http://MelodyZhy.github.io/tags/UI/"/>
    
  </entry>
  
</feed>
